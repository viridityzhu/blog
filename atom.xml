<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianke Youke</title>
  
  <subtitle>A Base for Secreting and Running at Night</subtitle>
  <link href="https://jyzhu.top/atom.xml" rel="self"/>
  
  <link href="https://jyzhu.top/"/>
  <updated>2022-04-07T15:34:41.597Z</updated>
  <id>https://jyzhu.top/</id>
  
  <author>
    <name>Jiayin Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Live demo of CodeTyping via Pythonanywhere</title>
    <link href="https://jyzhu.top/live-demo-of-code-typing-via-pythonanywhere/"/>
    <id>https://jyzhu.top/live-demo-of-code-typing-via-pythonanywhere/</id>
    <published>2022-04-07T15:24:15.000Z</published>
    <updated>2022-04-07T15:34:41.597Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://user-images.githubusercontent.com/39082096/149967763-a9bb56c5-6411-4d86-90d3-f1e22845e2a8.png" alt="image" /><figcaption>image</figcaption></figure><p><a href="http://jyzhu.pythonanywhere.com/">Code Typing Practice</a> (or source code on Github: <a href="https://github.com/viridityzhu/code-typing">here</a>) is a tiny web page that I wrote for fun last semester, which is for me myself to practice code typing. It is a naive Django web app (with bugs🤪). BUT! I find a service to deploy it lively today. That's what is worth noting down now.</p><span id="more"></span><h2 id="note">Note</h2><p>Initially I tried to deploy this demo on Vercel.com. But it was too troublesome coz it does not support Django by default. Thankfully, I found <a href="https://www.pythonanywhere.com/">pythonanywhere</a>, on which each user can deploy one web app without payment. What's the best is that it is really easy to deploy: it provides access to Bash console.</p><p>Two things to be noted:</p><ol type="1"><li>Every 3 months, I have to login into the pythonanywhere to extend my web app, otherwise it will be killed.</li><li>The bug cost most of my time is that in the <code>view.py</code> I had used relative path to the static code files. However, I should use absolute path, with adding <code>BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code> ahead.</li></ol><h2 id="todo">TODO</h2><p>Actually, after learned the MERN frame this semester, I am now aware of how naive this project is. However, I love Python, so it doesn't matter if i still regard Django as a hobby🤨. Who knows... I haven't even spent my time on that course project...</p><p>Now that the live demo is achieved, I might think of polishing this little project a bit.</p><ul><li>[ ] Fix bugs. Though i've already forgotten what those bugs are...</li><li>[ ] Replace the stupid code snippets...</li><li>[ ] Add the feature to compute time cost and typing speed. Also, save typing records.</li><li>[ ] Explicitly support other kinds of typing materials, and also support uploading customize materials.</li></ul>]]></content>
    
    
    <summary type="html">&lt;figure&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/39082096/149967763-a9bb56c5-6411-4d86-90d3-f1e22845e2a8.png&quot; alt=&quot;image&quot; /&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://jyzhu.pythonanywhere.com/&quot;&gt;Code Typing Practice&lt;/a&gt; (or source code on Github: &lt;a href=&quot;https://github.com/viridityzhu/code-typing&quot;&gt;here&lt;/a&gt;) is a tiny web page that I wrote for fun last semester, which is for me myself to practice code typing. It is a naive Django web app (with bugs🤪). BUT! I find a service to deploy it lively today. That&#39;s what is worth noting down now.&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Django" scheme="https://jyzhu.top/tags/Django/"/>
    
    <category term="Python" scheme="https://jyzhu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>三月的人生主题是复杂性</title>
    <link href="https://jyzhu.top/complexity-again/"/>
    <id>https://jyzhu.top/complexity-again/</id>
    <published>2022-03-14T07:26:36.000Z</published>
    <updated>2022-03-14T07:48:22.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我放弃理解很多东西</p><p>我开始拥抱</p><p>惊人的复杂性</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=7326559292&amp;auto=1&amp;height=430"></iframe><p>这两天列了一个名叫「精神状况」的歌单，顾名思义，遴选了大抵是最能有效表达我近来精神状况的9首歌（不出所料以摇滚为主）。奇妙的是，一方面我自诩听歌时对歌词甚是重视，另一方面最爱的歌竟然歌词含量不足50%。想想现实，或许是我放弃理解很多东西（用理性），开始拥抱复杂性了吧（用感性？）。</p><p><img src="https://s2.loli.net/2022/03/14/W5bxdr9w3egqRGF.jpg" style="zoom: 33%;" /></p><hr /><h3 id="最近随想">最近随想：</h3><ul><li>「活着很累，在漫长的生命中，积累的痛苦与折磨会变得绵长。」所以人长大了开始喝酒，一遍遍喝酒，只是因为积压的痛苦无法消解吧。不过这样的好处就是会有一天不再像年轻时候那样怕死了</li><li>我很悲戚，这个世界的悲戚底色近年也逐渐显露，看得浅的人也能举目就看见灰黑色了。很无望，年复一年埋头活着，一抬头就搞不清楚在盼什么。想到父母渐老，大小毛病接连不断；就连我自己都开始显露一些身体不好的迹象，就实在是难过。想到我的生活，海外留学，专业学术，与父母的生活，柴米油盐，家长里短，我们的世界是割裂的，我整个人也感到一种割裂，待在父母身边或者远方，都很悲哀。这种悲哀甚至只是稍纵即逝的，它哪怕能长存一些，我也能对生活稍多些把握。只是时间总会过得很快，可预见的未来还会面临变更，伴随更深、更无力的悲哀，例如作为一个成年人需承担的一个家庭的压力，例如重要的人的衰老、疾病、死亡。</li><li>我有时候对人生很随便，糟糕境遇的发生会被钝感而忽略，或者很快视若无睹，例如疫情和疫情后的世界。只是每一件事，也不至于对我全无影响，我的荒诞感随着它们一层一层加深。</li><li>昨天去外公墓上挂社了，和妈妈、外婆一起。外婆跟外公说很多话，问他这里风景好不好，有没有去哪里钓鱼。妈妈偷偷抹了几次眼泪。我最没用，眼泪大颗大颗滴在纸钱上，都不好烧了。可是我看见墓碑上外公的名字，他笑容灿烂的彩色照片，只是很想念很想念。妈妈让我作揖的时候可以心里跟外公说一些话，告诉他不要担心、请他保佑。可是我一边作揖一边心里只有一个声音：尕公啊 尕公诶[泪]</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我放弃理解很多东西&lt;/p&gt;
&lt;p&gt;我开始拥抱&lt;/p&gt;
&lt;p&gt;惊人的复杂性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;450&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;amp;id=7326559292&amp;amp;auto=1&amp;amp;height=430&quot;&gt;
&lt;/iframe&gt;
&lt;p&gt;这两天列了一个名叫「精神状况」的歌单，顾名思义，遴选了大抵是最能有效表达我近来精神状况的9首歌（不出所料以摇滚为主）。奇妙的是，一方面我自诩听歌时对歌词甚是重视，另一方面最爱的歌竟然歌词含量不足50%。想想现实，或许是我放弃理解很多东西（用理性），开始拥抱复杂性了吧（用感性？）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/14/W5bxdr9w3egqRGF.jpg&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>复杂性</title>
    <link href="https://jyzhu.top/complexity/"/>
    <id>https://jyzhu.top/complexity/</id>
    <published>2022-03-14T07:22:53.000Z</published>
    <updated>2022-03-14T07:26:15.368Z</updated>
    
    <content type="html"><![CDATA[<p>我放弃理解很多东西</p><p>我开始拥抱</p><p>惊人的复杂性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我放弃理解很多东西&lt;/p&gt;
&lt;p&gt;我开始拥抱&lt;/p&gt;
&lt;p&gt;惊人的复杂性&lt;/p&gt;
</summary>
      
    
    
    
    <category term="poems" scheme="https://jyzhu.top/categories/poems/"/>
    
    
  </entry>
  
  <entry>
    <title>Reading Pixel2Mesh++: Multi-View 3D Mesh Generation via Deformation</title>
    <link href="https://jyzhu.top/Reading-Pixel2meshPP/"/>
    <id>https://jyzhu.top/Reading-Pixel2meshPP/</id>
    <published>2022-02-06T09:59:29.000Z</published>
    <updated>2022-03-14T07:49:35.086Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：https://arxiv.org/abs/1908.01491</p><p>作者：Chao Wen, Yinda Zhang, Zhuwen Li, Yanwei Fu</p><p>发表： ICCV 2019</p><p>链接： https://arxiv.org/abs/1908.01491</p><hr /><blockquote><p>如果你去做这个任务，会怎么做？作者做的方法和你想的有什么差异？</p></blockquote><h2 id="why">Why：</h2><ol type="1"><li>单视角图像3D重建模的效果不够好，尤其是背面，而且泛化能力也差。</li><li>所以增加多个视角的图像：更多视觉信息，且有已经定义得很好的传统方法。</li><li>但是传统方法需要更大量的图像；这时候深度学习模型可以隐式编码视角间的关联，就派上了用场。</li><li>很有用，但是欠研究。</li></ol><h2 id="what">What：</h2><ol type="1"><li>利用多视角图像，固定相机pose参数，利用GCN，从粗糙逐渐精细地变形，生成3D mesh重建模。</li><li>采样mesh模型顶点周围的区域，利用perceptual feature推理出对mesh的形变。</li><li>对于不同种类的物体泛化能力很好。</li></ol><p>读前疑问：</p><ol type="1"><li>似乎就是给pixel2mesh加上一层壳，应用在多视角图像上🤔那么这里的创新点本质在哪儿呢？</li><li>GCN用处大吗，为什么用它？</li><li>采样mesh顶点周围的区域，是什么意思？</li><li>多视角3D重建，应用真的广泛吗？</li></ol><h2 id="how">How：</h2><ol type="1"><li>多视角变形网络 Multi-View Deformation Network (MDN)</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文地址：https://arxiv.org/abs/1908.01491&lt;/p&gt;
&lt;p&gt;作者：Chao Wen, Yinda Zhang, Zhuwen Li, Yanwei Fu&lt;/p&gt;
&lt;p&gt;发表： ICCV 2019&lt;/p&gt;
&lt;p&gt;链接： https://arxiv.org/abs/1908.01491&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Computer Vision" scheme="https://jyzhu.top/tags/Computer-Vision/"/>
    
    <category term="Deep Learning" scheme="https://jyzhu.top/tags/Deep-Learning/"/>
    
    <category term="3D Reconstruction" scheme="https://jyzhu.top/tags/3D-Reconstruction/"/>
    
  </entry>
  
  <entry>
    <title>Reading Self-supervised Single-view 3D Reconstruction via Semantic Consistency</title>
    <link href="https://jyzhu.top/Reading-Self-supervised-Single-view-3D-Reconstruction-via-Semantic-Consistency/"/>
    <id>https://jyzhu.top/Reading-Self-supervised-Single-view-3D-Reconstruction-via-Semantic-Consistency/</id>
    <published>2022-01-22T06:49:01.000Z</published>
    <updated>2022-02-05T10:17:41.929Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：https://arxiv.org/abs/2003.06473</p><p>作者：Xueting Li, Sifei Liu, Kihwan Kim, Shalini De Mello, Varun Jampani, Ming-Hsuan Yang, and Jan Kautz</p><p>发表： ECCV 2020</p><p>链接： https://github.com/NVlabs/UMR</p><hr /><blockquote><p>如果你去做这个任务，会怎么做？作者做的方法和你想的有什么差异？</p></blockquote><h2 id="why">Why：</h2><ol type="1"><li>在3d重建模任务中，同时预测形状、相机位置和材质是一个很大的问题，因为它内在的不确定性。</li><li>现有方法都需要借助各种手段：3D层面的监督、2D语义关键点、shading（这是什么？）、特定类别的3D template 、多视角等等。这些方法需要大量人力，所以很难广泛应用。</li><li>人类会直觉感知到一个物体包括各个部分，比如鸟有两只腿、两个翅膀、一个头，从而识别物体。类似的，cv受此启发，也可以将一个物体定义为多个可变形的部分的集合。</li></ol><h2 id="what">What：</h2><ol type="1"><li>仅需要单张图片+轮廓mask，利用语义一致性，实现自监督3D重建模</li><li>思路：1. 每个物体可以看作由可变形的部分组成；2. 对同一类型的不同物体，它们的每一部分在语义上都是一致的</li><li>通过自监督学习大量同类的图片，可以建立重建的mesh模型与图片之间的语义一致性。这样在同时预测形状、相机位置和材质的时候，可以降低模糊性。</li><li>第一个做到不需要特定类别的template mesh模型或者语义关键点，就可以从单视角图像中实现3d重建模。因此，这个方法可以推广到各种物体类别，而不需要类别的标签</li></ol><p>读前疑问：</p><h2 id="how">How：</h2><h3 id="模型">模型</h3><figure><img src="https://s2.loli.net/2022/01/27/x2BKozeFVpgUPkE.png" alt="image-20220122145159190" /><figcaption>image-20220122145159190</figcaption></figure><ol type="1"><li>（a）是原始图片。需要同一类别的大量图片一起作为输入</li><li>（b）用SCOPS模型（另一篇工作），对图像进行语义分割的结果。这个模型也是自监督的</li><li>（c）标准语义 uv map（Canonical semantic uv map）：<ol type="1"><li>理论上，同一类物体的mesh模型，尽管各自都有不同的形状，但每个点的语义含义都是一致的。</li><li>因此，根据前一步生成的大量语义分割结果，可以生成一张对应这个类别的Canonical语义uv map。</li></ol></li><li>（d）由前一步生成的Canonical语义uv map，可以得到重建的mesh模型表面的点对应的语义标签</li><li>橘色箭头：这个就是语义一致性了，它鼓励2D图像和3D模型之间的语义标签相互一致。这样，就可以解决前面提到过的在3D重建模的时候的“相机-形状不确定性”这个难题</li></ol><h3 id="具体方法">具体方法</h3><h4 id="cmr是baseline">CMR是baseline</h4><ol type="1"><li>用三个decoder <span class="math inline">\(D_{shape}\ D_{camera}\ D_{texture}\)</span> 同时预测mesh模型的形状、相机和材质<ol type="1"><li>形状 <span class="math inline">\(V=\tilde V + \Delta V\)</span>，其中 $V $ 是某类物体的template mesh模型，<span class="math inline">\(\Delta V\)</span> 是预测出来的点的偏移量</li><li>相机pose <span class="math inline">\(\theta\)</span> 是 weak perspective transformation （？）</li><li>材质 <span class="math inline">\(I_{flow}\)</span> 是 UV flow，是将输入图片到UV空间的映射，然后它可以被一个已经定义好的函数<span class="math inline">\(\phi\)</span>映射到mesh模型的表面的每一个点</li></ol></li><li>但是CMR需要人工标注的关键点作为输入，这篇论文主要就是把它去掉了。去掉之后呢，会出现相机+形状同时预测时Ambiguity的问题，所以就想方设法解决这个问题。</li></ol><figure><img src="https://s2.loli.net/2022/01/27/TkWsiJxMN38tKGu.png" alt="image-20220122160143711" /><figcaption>image-20220122160143711</figcaption></figure><h4 id="语义一致性解决相机形状同时预测时的ambiguity">语义一致性：解决相机+形状同时预测时的Ambiguity</h4><p>也就是Fig 3中红色框的部分。</p><ol type="1"><li><p><em>语义部件不变性 semantic part invariance：</em></p><ol type="1"><li>对于2D图像，用SCOPS（自监督co-part语义分割，另一篇论文的方法）可以很准确地对物体各个部分进行分割</li><li>对于3D mesh，每个点的语义含义是固定不变的，就算每个物体会有各自的形变</li></ol></li><li><p><em>语义一致性</em>：</p><ol type="1"><li><p><img src="https://s2.loli.net/2022/01/27/TzCkKA462gRbOFa.png" alt="image-20220124121618081" style="zoom:50%;" /></p><p>从Fig 4 (i) 可以看到，如果没有语义一致性，mesh模型中原本对应头的顶点被当作了翅膀尖，这样错误的变形对应了错误的相机pose。这就是相机+形状同时预测时的Ambiguity。</p></li><li><p>前面已经提到过，可以为每个具体类别生成一张标准语义 uv map（Canonical semantic uv map）。这里，就可以让 每个物体的2D语义分割结果 与 标准语义 uv map 保持一致性，从而让3D模型的每个语义部件跟2D图像里相应的位置有对应关系。这样可以很好地解决相机-形状Ambiguity问题。</p></li></ol></li></ol><h5 id="通过scops实现2d图像中部件的分割">通过SCOPS实现2D图像中部件的分割</h5><p><img src="https://s2.loli.net/2022/01/27/YFNpoKzfxkBRSbI.png" alt="image-20220124114332065" style="zoom:50%;" /></p><p>SCOPS 是自监督的方法，从一类物体的大量图片中发掘共同的语义部件。Fig 10第二行就是它的结果。后面还会提到，通过本文的方法，还可以反过来提升SCOPS的结果：利用生成的标准语义UV map作为伪标注反过来进行监督。</p><h5 id="通过标准语义uv-map实现3d模型中部件的分割">通过标准语义uv map实现3D模型中部件的分割</h5><ol type="1"><li><p>已经有了：</p><ol type="1"><li>模型学到的texture flow <span class="math inline">\(I_{flow}\)</span>可以将输入图片映射到UV空间，然后它可以被一个已经定义好的函数<span class="math inline">\(\phi\)</span>映射到mesh模型的表面的每一个点</li><li>通过SCOPS生成的图像 <span class="math inline">\(i\)</span> 的语义分割结果 <span class="math inline">\(P^i\in R^{H\times W\times N_p}\)</span>， 其中H和W是长和宽， <span class="math inline">\(N_p\)</span> 是语义部件数量</li></ol></li><li><p>这样的话，通过模型的 <span class="math inline">\(I_{flow}\)</span> 就可以把2D的语义分割结果 <span class="math inline">\(P^i\)</span> 映射到 UV 空间，把这个称为 语义UV map</p></li><li><p>理论上来说，同一类别的所有物体都应该得到同一个语义UV map，因为 1. 根据语义部件不变性，mesh模型的每个顶点对应的语义部件都是固定不变的 2. UV map和3d mesh 中的点又是通过<span class="math inline">\(\Phi\)</span>映射的关系，每个顶点对应的UV map上的坐标也是不变的。</p></li><li><p>但是因为SCOPS + <span class="math inline">\(I_{flow}\)</span> 的误差，各个物体生成的语义UV map事实上很不一样。所以这里提出了对 标准语义UV map <span class="math inline">\(\bar P_{uv}\)</span> 的估计方法：</p><ol type="1"><li><p>通过某种方法选择出训练集中效果比较好的子集 <span class="math inline">\(\mathcal{U}\)</span>，对它们的结果进行加和，</p><p><strong>选择样本的方式</strong>：</p><ol type="1"><li>首先选择最好的那一个样本，即 perceptual distance（3D投影到2D的图像与原始RGB图像的知觉距离？）最小的</li><li>然后选择K个跟这个最好的样本最接近的样本，即它们的语义UV map最接近</li></ol><p>公式如下：</p></li><li><p><span class="math display">\[\bar P_{uv}=\frac{1}{|\mathcal{U}|}\sum_{i\in \mathcal{U}}I^i_{flow}(P^i)\]</span></p><p>其中 <span class="math inline">\(I^i_{flow}(P^i)\)</span> 就是通过 <span class="math inline">\(I_{flow}\)</span> 映射语义分割结果 <span class="math inline">\(P^i\)</span> 得到的 语义UV map。</p></li></ol></li></ol><h5 id="d-和-3d-间的语义一致性">2D 和 3D 间的语义一致性</h5><ol type="1"><li><p><em>基于概率的约束 Probability-based constraint</em></p><ol type="1"><li><p><span class="math display">\[L_{sp}=||P^i-\mathcal{R}(\Phi (\bar P_{uv});\theta^i)||^2\]</span></p><p>标准语义UV map <span class="math inline">\(\bar P_{uv}\)</span> 由预定义好的函数 <span class="math inline">\(\Phi\)</span> 映射到 3D mesh表面，然后采用预测好的相机pose <span class="math inline">\(\theta^i\)</span> ，用可微分渲染 <span class="math inline">\(\mathcal{R}\)</span> 将3D模型渲染到2D，然后将结果与对应的由SCOPS生成的部件分割概率图 <span class="math inline">\(P^i\)</span> 做均方误差。</p></li><li><p>注：这个由SCOPS生成的图像分割结果 <span class="math inline">\(P^i\)</span> 是概率数值的形式</p></li><li><p>经验性地选择了采用均方误差MSE，比 KullbackLeibler divergence 效果好</p></li></ol></li><li><p><em>基于顶点的约束 Vertex-based constraint</em></p><ol type="1"><li><p>让3D模型投影回2D之后，被分类到某个语义part的顶点仍然处在图像中该part对应的区域</p></li><li><p><span class="math display">\[L_{sv}=\sum^{N_p}_{p=1} \frac{1}{|\bar V_p|}Chamfer(\mathcal{R}(\bar V_p;\theta^i),Y_p^i)\]</span></p><p>其中，<span class="math inline">\(\bar V_p\)</span> 是已经学好的某类物体的template mesh中属于部件p的那部分，<span class="math inline">\(Y_p^i\)</span>是原始2D图像中属于部件p的那部分，<span class="math inline">\(N_p\)</span> 是语义部件数量。</p></li><li><p>用Chamfer distance是因为投影后的顶点和原始的像素点并不是严格一对一对应的关系</p></li><li><p>用某类物体的template mesh，就可以让网络学相机pose；反之，假如用单个具体物体的mesh的话，网络就仅仅会对3D物体的形状进行扭曲，不会学到正确的相机pose了【我有点不理解为啥】</p></li></ol></li></ol><h3 id="渐进的训练方法em">渐进的训练方法EM</h3><ol type="1"><li><p>之所以要用渐进式训练，是因为</p><ol type="1"><li>需要3D重建模网络首先学会一个大体上可用的texture encoder <span class="math inline">\(I_{flow}\)</span>，然后才能生成标准语义UV map，</li><li>这样还能先生成对应具体类别的template mesh，一方面加速网络的收敛，一方面可以用在前面提到的<em>基于顶点的约束</em>中。</li></ol></li><li><p>但是，如果直接把template mesh和重建模模型全都一起学习的话，效果不好；所以就提出了：EM训练步骤（expectation-maximization期望最大化？），就是先固定一部分学习另一部分。</p><ol type="1"><li><p><strong>E</strong>：固定标准语义UV map和template（初始是球体），<strong>训练重建模网络</strong>。200轮。</p><p>loss包括：</p><ol type="1"><li><p>3D投影到2D的图像与gt剪影的 IoU ✖️ -1</p></li><li><p>3D投影到2D的图像与原始RGB图像的 perceptual distance（知觉距离？）</p></li><li><p>前面提到的基于概率的约束和基于顶点的约束</p></li><li><p>材质循环一致性 Texture cycle consistency：</p><ol type="1"><li><figure><img src="https://s2.loli.net/2022/01/27/SU3aFdKZrOtAiws.png" alt="image-20220124182432533" /><figcaption>image-20220124182432533</figcaption></figure><p>学习texture flow的时候最大的问题：颜色相似的3D mesh的面会被对应到错误的2D图像的像素点上</p></li><li><p>这是一个cycle：强制预测出来的texture flow（2D to 3D）和相机投影（3D to 2D）二者一致。</p></li><li><p>首先定义了<span class="math inline">\(\mathcal{C}_{in}^j\)</span>、 <span class="math inline">\(\mathcal{C}_{out}^j\)</span>分别是输入图像中被映射到三角形面<span class="math inline">\(j\)</span>的一定数量像素点的几何中心，和从三角形面<span class="math inline">\(j\)</span>渲染回2D图像时对应的一定数量像素点的几何中心。公式如下： <span class="math display">\[\mathcal{C}_{in}^j = \frac{1}{N_c}\sum^{N_c}_{m=1}\Phi(I_{flow}(\mathcal{G}^m))_j;\\ \mathcal{C}_{out}^j = \frac{\sum^{H\times W}_{m=1}\mathcal{W}_j^m\times \mathcal{G}^m}{\sum^{H\times W}_{m=1}\mathcal{W}_j^m}\]</span> 其中，<span class="math inline">\(\mathcal{G}^m\)</span>是投影图像的标准坐标网格（包含了像素的坐标<span class="math inline">\((u,v)\)</span>值），<span class="math inline">\(\Phi\)</span>是UV map，<span class="math inline">\(I_{flow}\)</span>把像素映射到3D mesh的面<span class="math inline">\(j\)</span>上；<span class="math inline">\(N_c\)</span>是对应到面<span class="math inline">\(j\)</span>的像素点的数量；<span class="math inline">\(\mathcal{W}\)</span>是可微分渲染时生成的概率map，每个<span class="math inline">\(\mathcal{W}_j^m\)</span>表示面 j 被投影到像素 m 上的概率。</p><ul><li>把重建模mesh模型渲染成2D图像，用的是 Soft Rasterizer，而不是CMR中用的 Neural Mesh Renderer，因为前者可以提供概率map，供texture cycle consistency使用</li></ul></li><li><p>那么，材质循环一致性就是让<span class="math inline">\(\mathcal{C}_{in}^j\)</span>接近 <span class="math inline">\(\mathcal{C}_{out}^j\)</span>： <span class="math display">\[L_{tcyc} = \frac{1}{|F|}\sum^{|F|}_{j=1}||\mathcal{C}_{in}^j-\mathcal{C}_{out}^j||^2_F\]</span></p></li></ol></li><li><p>还有写在附录里的两个loss：</p><ol type="1"><li>graph Laplacian constraint 来鼓励mesh表面平滑【从pixel-mesh中来的】</li><li>edge regularization 来惩罚大小不规则的面 代码里似乎是flatten loss</li></ol></li><li><p>还有写在附录里的对抗训练loss</p></li></ol></li><li><p><strong>M</strong>：利用训练好的重建模网络，更新template（从球体开始）和标准语义UV map。</p><ol type="1"><li><p>template一开始是球体，然后每训练K轮，对它进行一次更新： <span class="math display">\[\bar V_t=\bar V_{t-1} + D_{shape}(\frac{1}{|\mathcal{Q}|}\sum_{i\in \mathcal{Q}}E(I^i))\]</span> <span class="math inline">\(V_{t}\)</span>和 <span class="math inline">\(V_{t-1}\)</span>是更新前后的template，I是输入的图片，经过E生成3D属性，D是形状 encoder。Q是经过某种方式选择出来的部分样本。</p><p><strong>选择样本的方式</strong>：</p><ol type="1"><li>首先选择最好的那一个样本，即与ground truth轮廓的IoU最小的</li><li>然后选择K个跟这个最好的样本最接近的样本，即这些样本的gt轮廓与最好的样本的gt轮廓的IoU越小则越接近</li></ol></li><li><p>这样的话，template <span class="math inline">\(V_t\)</span> 就是选出来的样本的平均形状</p></li></ol></li><li><p>整个训练过程会包括两轮，每轮都包括一个E和一个M。（两轮分别就是代码中的<code>train_s1</code> <code>train_s2</code>。）在E中，训练200 epoch 重建模网络，然后在M中用训练好的网络更新template和标准语义UV map。注意在第一轮中（一轮包括一个E和M），只训练重建模网络，而没有语义一致性约束。</p></li></ol></li></ol><h3 id="实验">实验</h3><ol type="1"><li>数据集：PASCAL3D+中的车和摩托车、CUB-200-2011中的鸟、ImageNet中的马 斑马 牛、OpenImages中的企鹅</li><li>局限性：<ol type="1"><li>依赖于SCOPS提供语义分割，有时候语义分割不准确的话结果就不好</li><li>比较少见的相机pose很难</li><li>细节性的地方效果不好，比如正在飞的鸟的两个翅膀、斑马的腿等</li></ol></li></ol><h1 id="questions">Questions</h1><ol type="1"><li><p>为什么要stage2 ？</p><ol type="1"><li>这两个 stage的主要区别就是：stage1的时候没有用语义一致性约束，在stage2才加上。因为一开始texture flow encoder效果并不好，avg_uv也不准确，所以干脆先不用。所以分成s1和s2，最主要的就是因为在s1训练完之后，重建模网络已经大体可以用了，这时候就可以调用<code>avg_uv.py</code>来生成标准语义UV map，供s2的时候语义一致性用。</li><li>附录里说，从效果上来看，2个stage比1个效果要好，且已经足够好了，有这张图对比了一下：<img src="https://s2.loli.net/2022/01/27/Q26BbRypnrKj7AU.png" alt="image-20220127171646865" /></li></ol></li><li><p>avg_uv 就是学 seg map -&gt; uv map的么？</p><ol type="1"><li>seg map -&gt; uv map这个过程是重建模网络中texture flow这个部分做的事情</li><li>avg_uv就是论文里说的 标准语义 uv map（Canonical semantic uv map）：<ol type="1"><li>理论上，同一类物体的mesh模型，尽管各自都有不同的形状，但每个点的语义含义都是一致的</li><li>因此，对于某一类物体的大量图像数据集（比如鸟），可以生成一张对应这整个类别的avg_uv</li><li>利用这个avg_uv，相当于是给整个类别的template打上了语义标签，后续计算语义一致性约束的时候可以用。</li><li>这个avg_uv的计算过程：<ol type="1"><li>首先用SCOPS（另一篇工作，无监督的）生成所有图像的语义分割结果seg map，然后用重建模网络学到的texture flow映射成uv map</li><li>选择效果最好的一部分instances，对它们的uv map取平均，得到avg_uv</li></ol></li></ol></li></ol></li><li><p>paper 里面 有说固定camera 学shape？ 那代码里有fix camera预测么？</p><p>我好像没有读到paper里有具体说到固定camera学shape耶……</p><p>论文里提到要解决camera-shape一起学时的ambiguity的问题，但不是固定一个学另一个，而是利用avg_uv来实现语义一致性：让 每个物体的2D seg uv map 与 avg_uv 保持一致性，从而让3D模型的每个语义部件跟2D图像里相应的位置有对应关系。</p><p><img src="https://s2.loli.net/2022/01/27/TzCkKA462gRbOFa.png" alt="image-20220124121618081" style="zoom:50%;" /></p><p>从这张图里可以看到，如果没有语义一致性，mesh模型中原本对应头的顶点被当作了翅膀尖，这样的camera就是错误的，错误的camera又造成了错误的shape。而有了语义一致性，就能利用语义让camera 更准确，这样就能跟着提升shape</p></li><li><p>按照他的说法， 先是feature avg 然后 decode 出 average shape。那么这个feature就要学好一点，否则平均容易成球形。那么这个feature 还有其他loss在上面么？比如我们smr 上还有 consistency loss 但是加在 delta_vertice上？他有加在feature上么？否则不能确保这个 feature avg 了以后 还有意义</p><p>我可能没有懂这个问题耶……学长说的是不是计算category level 的 template这个步骤呢？我觉得这个步骤里面保证效果好的方式有这几点比较关键：</p><ol type="1"><li>更新category level 的 template是从M步骤才开始进行的；在此之前，E步骤中会在固定template的前提下，单独训练重建模网络200轮，这个过程中的loss还是挺多的，除了语义一致性没有用以外，其他的loss都用了，包括论文里提出的texture cycle consistency，还有附录里提到的graph Laplacian constraint、edge constraint等等</li><li>计算average template的时候，并不是用了所有数据，而是选择了最好的一部分instances：<ol type="1"><li>首先选择最好的那一个instance，即与ground truth mask的IoU最小的</li><li>然后选择K个跟这个最好的样本最接近的样本，即这些样本的gt mask与最好的样本的gt mask的IoU越小则越接近</li></ol></li></ol></li><li><p>代码里面还放了一些 external的code，有用到么？</p><ol type="1"><li>一个是SoftRas，用来把重建模mesh模型渲染成2D图像。论文里提到用它而不是CMR中用的 Neural Mesh Renderer，是因为它可以提供概率map，供texture cycle consistency使用</li><li>另一个是Neural Mesh Renderer，备选的renderer</li><li>再就是PerceptualSimilarity，用来计算了perceptual loss</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文地址：https://arxiv.org/abs/2003.06473&lt;/p&gt;
&lt;p&gt;作者：Xueting Li, Sifei Liu, Kihwan Kim, Shalini De Mello, Varun Jampani, Ming-Hsuan Yang, and Jan Kautz&lt;/p&gt;
&lt;p&gt;发表： ECCV 2020&lt;/p&gt;
&lt;p&gt;链接： https://github.com/NVlabs/UMR&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Computer Vision" scheme="https://jyzhu.top/tags/Computer-Vision/"/>
    
    <category term="3D Reconstruction" scheme="https://jyzhu.top/tags/3D-Reconstruction/"/>
    
    <category term="Self-supervised" scheme="https://jyzhu.top/tags/Self-supervised/"/>
    
  </entry>
  
  <entry>
    <title>rebellious-person</title>
    <link href="https://jyzhu.top/rebellious-person/"/>
    <id>https://jyzhu.top/rebellious-person/</id>
    <published>2022-01-09T20:21:06.000Z</published>
    <updated>2022-01-09T20:21:35.424Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候我觉得叛逆和听话并不是矛盾的特质。有一种本质的叛逆其实是想清楚了想要什么，然后选择了听话这一个行动模式。为什么说这是叛逆呢，因为这不是真的听话，是某种最极端的不听话。我已经见过了很多的乖乖人，许多一眼就能分辨出来，是真乖乖听话，还是叛逆人所伪装。这种伪装听话的叛逆人大概还有另一个特质，就是有多面性。很多人误把其特异的那些面当作真实面目，觉得听话一面是伪装；其实不然，全都是真实的样貌，没有必要分明。学习一个人要学会容忍他的复杂性。</p><p>我有想过用一些色彩更容易辨明的词来代替「叛逆」：自主，自知，清醒，成熟，明白自己想要什么……可是这都差了点意思。还是叛逆好，因为这毕竟有一种孤勇感在里面；也不贴切，大概是虫子蠕动的guyong感。想象这样一个画面：在肠道一样的世界里，大家都乖乖顺滑着逐渐化为某种排泄物，但是其中有一些guyong者，就是叛逆人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有的时候我觉得叛逆和听话并不是矛盾的特质。有一种本质的叛逆其实是想清楚了想要什么，然后选择了听话这一个行动模式。为什么说这是叛逆呢，因为这不是真的听话，是某种最极端的不听话。我已经见过了很多的乖乖人，许多一眼就能分辨出来，是真乖乖听话，还是叛逆人所伪装。这种伪装听话的叛逆人</summary>
      
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>obj format debugging -- vertices order determines face orientation and faces are invisible from back</title>
    <link href="https://jyzhu.top/obj-format-debugging-vertices-order/"/>
    <id>https://jyzhu.top/obj-format-debugging-vertices-order/</id>
    <published>2022-01-05T11:52:42.000Z</published>
    <updated>2022-01-05T12:10:49.164Z</updated>
    
    <content type="html"><![CDATA[<p>Okayyyyyyyy!!!</p><ol type="1"><li><p><strong>Vertices order determines face orientation</strong>.</p><p>e.g., <code>f 1 2 3</code> and <code>f 1 3 2</code> are 2 opposite faces</p></li><li><p>Another thing is, <strong>faces are invisible from backside by default!!!</strong></p><p>In <strong>Meshlab</strong> here is a setting <code>back-face</code> which by default is <code>single</code>. If set it as <code>double</code>, then the face will be visible from backside.<img src="https://s2.loli.net/2022/01/05/CjwX378IKQYpznb.png" /></p><p>Meanwhile, the <strong>Preview</strong> of MacOS also makes faces transparent from opposite orientation. Like this: <img src="https://s2.loli.net/2022/01/05/vVI5SZk1d8cCqx6.png" alt="Stupid sphere no?" style="zoom:50%;" /></p></li></ol><p>Finally my sphere is correct:</p><p><img src="https://s2.loli.net/2022/01/05/jyMqxdsRCiLDlSf.png" alt="correct sphere" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Okayyyyyyyy!!!&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Vertices order determines face orientation&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;e.g., &lt;code&gt;f 1 2 3&lt;/code&gt; and &lt;code&gt;f 1 3 2&lt;/code&gt; are 2 opposite faces&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another thing is, &lt;strong&gt;faces are invisible from backside by default!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Meshlab&lt;/strong&gt; here is a setting &lt;code&gt;back-face&lt;/code&gt; which by default is &lt;code&gt;single&lt;/code&gt;. If set it as &lt;code&gt;double&lt;/code&gt;, then the face will be visible from backside.&lt;img src=&quot;https://s2.loli.net/2022/01/05/CjwX378IKQYpznb.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Meanwhile, the &lt;strong&gt;Preview&lt;/strong&gt; of MacOS also makes faces transparent from opposite orientation. Like this: &lt;img src=&quot;https://s2.loli.net/2022/01/05/vVI5SZk1d8cCqx6.png&quot; alt=&quot;Stupid sphere no?&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally my sphere is correct:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/05/jyMqxdsRCiLDlSf.png&quot; alt=&quot;correct sphere&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Mesh" scheme="https://jyzhu.top/tags/Mesh/"/>
    
    <category term="3D" scheme="https://jyzhu.top/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>Last day of 2021</title>
    <link href="https://jyzhu.top/Last-day-of-2021/"/>
    <id>https://jyzhu.top/Last-day-of-2021/</id>
    <published>2021-12-31T09:17:59.000Z</published>
    <updated>2021-12-31T09:20:00.070Z</updated>
    
    <content type="html"><![CDATA[<p>没有太多要说的。这首词正好表达了一切我想表达的：</p><blockquote><p>一向年光有限身，等闲离别易销魂，酒筵歌席莫辞频。</p><p>满目山河空念远，落花风雨更伤春，不如怜取眼前人。</p><p>——晏殊《浣溪沙》</p></blockquote><p>共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没有太多要说的。这首词正好表达了一切我想表达的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一向年光有限身，等闲离别易销魂，酒筵歌席莫辞频。&lt;/p&gt;
&lt;p&gt;满目山河空念远，落花风雨更伤春，不如怜取眼前人。&lt;/p&gt;
&lt;p&gt;——晏殊《浣溪沙》&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
    <category term="Literature" scheme="https://jyzhu.top/tags/Literature/"/>
    
  </entry>
  
  <entry>
    <title>免于未来</title>
    <link href="https://jyzhu.top/release-future/"/>
    <id>https://jyzhu.top/release-future/</id>
    <published>2021-12-22T17:04:57.000Z</published>
    <updated>2021-12-22T17:09:10.767Z</updated>
    
    <content type="html"><![CDATA[<p>明天，太阳照常升起<br />世上所有的颜色将逐渐掩埋我眼中的悲伤<br />消失的国度 消失的人<br />我怎么相信啊<br />人怎么可能会消失呢<br />化作一抔黄土<br />去到另一个世界<br />没有人伤心的时候会不信彼岸吧？<br />何时也都能跳舞<br />只是舞在有些事面前都全无意义<br />除了生死<br />哪一桩不是闲事<br />每个人一生中都沉溺在无关紧要的琐事中<br />以免被生命的悲伤侵扰<br />以关闭感官<br />然而酒浇进大海的愁里<br />就好像把我掩埋在这个世界中<br />或者用这个世界的颜色掩埋我<br />或者用琐碎掩埋所有生者<br />可是掩埋一切吧<br />不要掩埋我的亲人<br />重要的亲人啊<br />多希望世界因你从此停摆<br />就停下来吧<br />让我免于未来<br />为什么明天<br />太阳还要照常升起啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;明天，太阳照常升起&lt;br /&gt;
世上所有的颜色将逐渐掩埋我眼中的悲伤&lt;br /&gt;
消失的国度 消失的人&lt;br /&gt;
我怎么相信啊&lt;br /&gt;
人怎么可能会消失呢&lt;br /&gt;
化作一抔黄土&lt;br /&gt;
去到另一个世界&lt;br /&gt;
没有人伤心的时候会不信彼岸吧？&lt;br /&gt;
何</summary>
      
    
    
    
    <category term="poems" scheme="https://jyzhu.top/categories/poems/"/>
    
    
    <category term="grandpa" scheme="https://jyzhu.top/tags/grandpa/"/>
    
  </entry>
  
  <entry>
    <title>My Grandfather</title>
    <link href="https://jyzhu.top/My-Grandfather/"/>
    <id>https://jyzhu.top/My-Grandfather/</id>
    <published>2021-12-22T16:57:42.000Z</published>
    <updated>2021-12-22T17:30:30.803Z</updated>
    
    <content type="html"><![CDATA[<p>我的外公去世了，转眼就快半个月了。这件事情在我心中，从不敢相信的说法，变成了模糊的、不真实的说法。我实际上时时提起，它在任何时候都萦绕在我脑中，以至于都很难相信已经过去半个月了；可是其实又很难提起，提起总显得轻飘飘的，这是压在我心中最沉重的一件事。</p><span id="more"></span><p>我当然很爱我的外公，他是一位正直、善良、坚强的人。我的脑中积攒了很多很多关于他的事迹，都是从外婆、妈妈口中听来的。</p><p>外公自己其实跟我交流得很少，时至今日印象最深刻的，竟然是小学的时候外公给我煮面吃，很严厉地批评我：面汤也必须喝完，不能浪费！小时候的我挑食、食量小，这个训诫让我很畏惧。可是我从来没想过面汤也是需要珍惜的事物，因此被外公点醒，也颇感惭愧。以至于记到今日，并且将刻进骨子里。</p><p>我高中的时候其实以十分饱满的感情，在一篇周记中认真地写过外公的事迹与形象。妈妈觉得很感动。我目前倒是不敢翻出来看。多少年后才会无意中看到，然后哭掉呢？我不敢想。</p><p>我的外公啊，他的人生过得应该很不容易的。从小失去双亲，人生中有过一段穷困潦倒的日子，才养成极度节约的习惯。他固执到偏执的程度，才成为这样一位威严的长辈，可是也正因为这性格，年轻时工作中受到过很大的挫折。他的头脑与才能一定是值得尊敬的，琴棋书画都会一些不说，还会修各种电路，拥有一个颇为神秘、包罗万象的工具柜。</p><p>外公迷信算命，我的名字就是他起的，经过很仔细的推算。弟弟出生的时候，外公虽然仍在世，但已经病重，遗憾没能给他起名了。妈妈说，一定是外公算了太多命，触犯了什么规则而受到惩罚，所以晚年自己命苦，云云。最后真的好苦啊，那样一位思维敏捷的智者，终日口不能述、手不能书，忍受着身体各处的疼痛，一天天因为营养不良而消瘦下去，生命的活力不可逆地暗淡下去。</p><p>这些生命不可逆的运动一度让我陷入最深的恐惧。我能想象，但我能想象几何呢。最后一次见到外公已是半年前了，后来的外公是什么样子呢。他在我心中的形象，一切的事迹，相关的回忆，都已经在时间中定格了。</p><p>这是我最伤感的事情。</p><p>一个人还活着，那意味着随着时间，他也是在流动的。可是一个人死去，他就凝固了，这是我还不能接受的事情。跟永恒相比，人的一生短暂得要命。跟浩瀚相比，人的命轻得不值一提。但在我心中，重要的人，其重量就是无法衡量的，其离去就是切切实实地，将我的生命也随之割去了一部分。然而，关于我的生命被割走这件事，我感到感激，也感到踏实。</p><p>我的感想在人之逝世这件事面前，多少微不足道。但我仍然会一遍遍地回忆这件事，我会再一遍遍地提起这件事。这是我对外公思念的方式。</p><blockquote><p>我知道这世界本如露水般短暂。然而然而。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的外公去世了，转眼就快半个月了。这件事情在我心中，从不敢相信的说法，变成了模糊的、不真实的说法。我实际上时时提起，它在任何时候都萦绕在我脑中，以至于都很难相信已经过去半个月了；可是其实又很难提起，提起总显得轻飘飘的，这是压在我心中最沉重的一件事。&lt;/p&gt;</summary>
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
    <category term="grandpa" scheme="https://jyzhu.top/tags/grandpa/"/>
    
  </entry>
  
  <entry>
    <title>读 DeepHuman: 3D Human Reconstruction from a Single Image</title>
    <link href="https://jyzhu.top/DeepHuman-3D-Human-Reconstruction-from-a-Single-Image/"/>
    <id>https://jyzhu.top/DeepHuman-3D-Human-Reconstruction-from-a-Single-Image/</id>
    <published>2021-12-15T06:46:11.000Z</published>
    <updated>2022-02-05T09:45:06.464Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：<a href="https://openaccess.thecvf.com/content_ICCV_2019/html/Zheng_DeepHuman_3D_Human_Reconstruction_From_a_Single_Image_ICCV_2019_paper.html" class="uri">https://openaccess.thecvf.com/content_ICCV_2019/html/Zheng_DeepHuman_3D_Human_Reconstruction_From_a_Single_Image_ICCV_2019_paper.html</a></p><p>作者：Zerong Zheng, Tao Yu, Yixuan Wei, Qionghai Dai, Yebin Liu</p><p>发表： ICCV2019</p><p>Code： <a href="https://github.com/ZhengZerong/DeepHuman" class="uri">https://github.com/ZhengZerong/DeepHuman</a></p><hr /><blockquote><p>如果你去做这个任务，会怎么做？作者做的方法和你想的有什么差异？</p></blockquote><h2 id="why">Why：</h2><ol type="1"><li>现在的人体重建模工作大多需要多视角图像或者多temporal图像，从单张图像重建人体仍然是具有挑战性的工作。</li><li>单张图像重建模的工作，就算是利用人体template（SMPL）的，最好的效果也只是重现形状和姿势，但是在服装层面上的呈现效果很差。BodyNet已经尝试了，但是效果也很差。</li><li>现在的公开数据集都没有大分辨率的、包含普通服饰的表面特征的3D人体数据集。所以只好自己搞了一个。</li></ol><h2 id="what">What：</h2><ol type="1"><li>提出了DeepHuman，体到体（volume to volume）的3D人体重建模</li><li>将从SMPL模型生成的 稠密语义表示 作为额外的输入，来让重建的物体表面更清晰，甚至还能重建不可见的部分</li><li>通过体积特征变换（volumetric feature transformation），把不同尺度的图像特征融合起来，得以恢复精确的表面；然后通过正则提炼网络（normal refinement network)进一步细化表面</li><li>顺便提出了THuman数据集</li></ol><p>读前疑问：</p><ol type="1"><li>SMPL模型是哪来的？震惊，是需要利用HMR之类的方法先生成一个SMPL人体模型，然后再和图像一起作为输入，所以这篇论文是跟前半部分工作——生成SMPL模型——一点关系没有的🤔</li><li>不是自监督吧？不是的，是有3D mesh ground truth的</li><li>看起来效果很好，模型中应该利用了一些bottom-up的人体结构先验知识吧？我猜是不是先用的SMPL构建人体，然后再额外增加一部分网络结构，把人体表面重建得更好呢？没错。</li><li>normal refinement network是啥呢？normal是法线啦，我理解这个其实就是一个简单的UNet网络，把法线贴图upsample成两倍大小</li><li>不同scale的图像特征是怎么利用的？这里提出了一个VFT来把图像特征融合进volume特征里。图像特征怎么来的，简单的conv+relu。volume特征怎么来的，一个立体改良版UNet。所以具体做法就是，在UNet的downsample过程中的每一层，都进行一次VFT，把图像特征融合进volume特征里面。</li><li>THuman数据集好用吗？我看这篇论文有一百多的引用，是因为大家都用上了这个数据集吗？不知道诶……</li></ol><h2 id="how">How：</h2><ol type="1"><li>服装层面的重建模要做好，需要分解成两方面：<ol type="1"><li><em>可视区域的变形自由度要被限制，不然人体结构会被破坏。</em> 为此，这篇文章提出除了原始图像以外，还额外加上两种参数化的人体模型，包括3D语义体+对应的2D语义map</li><li><em>模型要能提取出几何信息，比如服装风格和皱纹。</em> 为此，提出了多尺度体积特征转换。 最后再通过法线投影层，连接生成网络和精炼网络</li></ol></li><li>总的来说，分成3个子任务：<ol type="1"><li>输入图像 -&gt; 参数化人体模型</li><li>图像+人体模型 -&gt; 表面重建</li><li>图像 -&gt; 可视表面再度精细化</li></ol></li><li>THuman数据集，包括7000个穿着230种服装的随机姿势的人体mesh</li></ol><h3 id="模型">模型：</h3><figure><img src="https://s2.loli.net/2021/12/19/GX1IB39Yb5OwAoe.png" alt="image-20211217121247234" /><figcaption>image-20211217121247234</figcaption></figure><ol type="1"><li>对于每个三维模型顶点，生成一个包含3个维度的语义码，包含其空间坐标+姿势信息，映射到二维图像I上，得到语义map Ms</li><li>体素化smpl模型，然后把语义码传播到对应体素中，得到语义体Vs</li><li>定义一个128*192*128的3d占据空间(occupancy volume) Vo，其中表面以内的所有体素值设为1，以外的为0。通过一个图像导向的体到体翻译网络，靠I和Ms的协助，把Vs重建模为Vo</li><li>因为体素体的像素有限，所以最后再用一个UNet，直接把Vo投影成一个2D<a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE">法线贴图(Normal map)</a> N，也就相当于是可视的表面</li><li>总的来说，模型由三部分组成<ol type="1"><li>图像编码G</li><li>体到体转换网络vol2vol</li><li>法线精炼网络R</li></ol></li></ol><h4 id="图像编码-g">图像编码 G</h4><p>结合I和Ms，得到多尺度的2D特征maps <span class="math inline">\(M_f^{(k)}(k=1,...,K)\)</span></p><h4 id="体特征转换-volumetric-feature-transformation-vft">体特征转换 volumetric feature transformation VFT</h4><figure><img src="https://s2.loli.net/2021/12/19/EBjbG4PztH6cNVO.png" alt="image-20211217121317806" /><figcaption>image-20211217121317806</figcaption></figure><p>VFT这个东西把前面通过图像编码得到的多尺度的2D特征maps <span class="math inline">\(M_f^{(k)}(k=1,...,K)\)</span>融合到vol2vol网络中</p><ol type="1"><li>通过一个卷积+激活，把特征map <span class="math inline">\(M_F^{(k)}\)</span>映射到模块化参数<span class="math inline">\((\alpha_k, \beta_k)\)</span>中</li><li>因为此时<span class="math inline">\((\alpha_k, \beta_k)\)</span>是二维的，而语义体<span class="math inline">\(V_f^{(k)}\)</span>是三维的，所以这里是把<span class="math inline">\(V_f^{(k)}\)</span>在z轴上分成高度为1的一层一层的切片，然后分别跟<span class="math inline">\((\alpha_k, \beta_k)\)</span>做仿射变换（理解成线性变换+平移）</li><li>仿射变换：<span class="math inline">\(VFT(V_f^{(k)}(z_i))=\alpha_k\bigodot V_f^{(k)}(z_i) + \beta_k\)</span>。最后就能得到转换后的Vf了</li></ol><p>相比于直接把特征连接起来，VFT的好处就是说它可以更好地保存形状特征，而且更快更灵活。</p><h4 id="vol2vol">vol2vol</h4><ol type="1"><li>是一个3D的Unet，以Vs和<span class="math inline">\(M_f^{(k)}(k=1,...,K)\)</span>为输入，Vo为输出</li><li>在encoder阶段用VFT把Mf信息融合进Vf来；然后利用skip- connection，这个VFT的变换信息也是可以直接传递到decoder阶段的</li></ol><h4 id="体到法线贴图的投影层-r">体到法线贴图的投影层 R</h4><p>这是一个可微分的体积到法线的投影层，可以根据占据空间直接计算出法线贴图，实现人体表面细节的呈现。</p><figure><img src="https://s2.loli.net/2021/12/19/TL5dxOVwvJGiq9Q.png" alt="image-20211217121336401" /><figcaption>image-20211217121336401</figcaption></figure><ol type="1"><li>根据占据空间生成一个深度图depth map，上图4是生成depth map的步骤：<ol type="1"><li>4（a）中，蓝色圆是输入的模型，从 <span class="math inline">\(p=(x_p,y_p)\)</span> 点开始，沿着z轴扫描每一个体素点的占据情况，就能得到图4（b）</li><li>找到最近的被占据的体素点，即是深度值<span class="math inline">\(D(p)\)</span>，如图4（c）</li><li>这个方法虽然很直观，但是直接来算并不好算，所以实际上是采用一种对体素模型进行变换然后再求值的数学方法算的</li></ol></li><li>将depth map转化成顶点图vertex map，然后用数学方法计算出法线图normal map<ol type="1"><li>根据图像中的位置，把x和y坐标赋值给深度像素</li><li>然后用 Sobel 算子来计算顶点map沿x和y方向的方向导数：<span class="math inline">\(G_x=S_x*M_v,G_y=S_y*M_v,\)</span></li><li>像素点 <span class="math inline">\(p=(x_p,y_p)\)</span>的法线就可以直接计算出来：<span class="math inline">\(N^{(x_py_p)}=G_x(p)\times G_y(p)\)</span></li></ol></li><li>最后用一个 Unet 把 normal map Upsample到两倍大小</li></ol><h3 id="loss-functions">Loss functions</h3><ol type="1"><li><p>3D占据空间的重建模误差，用Binary Cross-Entropy (BCE)表示： <span class="math display">\[L_V = -\frac{1}{|\hat V_o|}\sum_{x,y,z} \gamma \hat V_o^{(xyz)} logV_o^{(xyz)}+(1-\gamma)(1-\hat V_o^{(xyz)})log(1-V_o^{(xyz)})\]</span> <span class="math inline">\(\hat V_o\)</span>是占据空间真实值，<span class="math inline">\(V_o^{(xyz)}\)</span> <span class="math inline">\(\hat V_o^{(xyz)}\)</span>都是在坐标<span class="math inline">\((x,y,z)\)</span>的体素点，<span class="math inline">\(\gamma\)</span> 是一个权重</p></li><li><p>2D剪影（silhouette）的重建模误差，是一个多视角重投影loss： <span class="math display">\[L_{FS} = -\frac{1}{|\hat S_{fv}|}\sum_{x,y} \hat S_{fv}^{(xy)}log S_{fv}^{(xy)}+(1-\hat S_{fv}^{(xy)})log(1-S_{fv}^{(xy)})\]</span> <span class="math inline">\(L_{FS}\)</span>是前视角（front-view）的剪影重投影loss，<span class="math inline">\(S_{fv}\)</span>是<span class="math inline">\(V_o\)</span>的剪影重投影，<span class="math inline">\(\hat S_{fv}\)</span>是相应的真实投影，$ S_{fv}^{(xy)}$ <span class="math inline">\(\hat S_{fv}^{(xy)}\)</span>是在坐标<span class="math inline">\((x,y)\)</span>的相应像素值。</p><p>侧面视角的loss <span class="math inline">\(L_{SS}\)</span>的定义如出一辙。</p></li><li><p>法线图的精炼误差，用余弦距离： <span class="math display">\[L_N = \frac{1}{|\hat N|}\sum_{x,y} 1-\frac{&lt;N^{(xy)},\hat N^{(xy)}&gt;}{|N^{(xy)}|\cdot |\hat N^{(xy)}|}\]</span></p></li><li><p>总loss： <span class="math display">\[L = L_V +\lambda_{FS}L_{FS} +\lambda_{SS}L_{SS}+\lambda_{N}L_{N}\]</span></p></li></ol><h3 id="thuman数据集">THuman数据集</h3><ol type="1"><li>用DoubleFusion方法捕捉3D人体mesh模型</li><li>数据集中包括7000个数据项，每一项有：表面包含了材质的mesh模型 + RGBD图像 + 对应的SMPL模型</li></ol><h3 id="实验">实验</h3><figure><img src="https://s2.loli.net/2021/12/19/acYy6ftBGLN7FRV.png" alt="image-20211217121419341" /><figcaption>image-20211217121419341</figcaption></figure><p>跟这几个比：HMR BodyNet SiCloPe</p><p>效果好极了</p><h3 id="讨论">讨论</h3><p>limitation：</p><ol type="1"><li>必须依赖HMR和SMPLify来为输入图像估计一个SMPL模型</li><li>不可见的地方被过度平滑了</li><li>手只能表示成一团，面部表情也不能刻画</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文地址：&lt;a href=&quot;https://openaccess.thecvf.com/content_ICCV_2019/html/Zheng_DeepHuman_3D_Human_Reconstruction_From_a_Single_Image_ICCV_2019_paper.html&quot; class=&quot;uri&quot;&gt;https://openaccess.thecvf.com/content_ICCV_2019/html/Zheng_DeepHuman_3D_Human_Reconstruction_From_a_Single_Image_ICCV_2019_paper.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：Zerong Zheng, Tao Yu, Yixuan Wei, Qionghai Dai, Yebin Liu&lt;/p&gt;
&lt;p&gt;发表： ICCV2019&lt;/p&gt;
&lt;p&gt;Code： &lt;a href=&quot;https://github.com/ZhengZerong/DeepHuman&quot; class=&quot;uri&quot;&gt;https://github.com/ZhengZerong/DeepHuman&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Computer Vision" scheme="https://jyzhu.top/tags/Computer-Vision/"/>
    
    <category term="Deep Learning" scheme="https://jyzhu.top/tags/Deep-Learning/"/>
    
    <category term="3D Reconstruction" scheme="https://jyzhu.top/tags/3D-Reconstruction/"/>
    
    <category term="Paper Reading" scheme="https://jyzhu.top/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>读：论视觉知识</title>
    <link href="https://jyzhu.top/%E8%AF%BB%EF%BC%9A%E8%AE%BA%E8%A7%86%E8%A7%89%E7%9F%A5%E8%AF%86/"/>
    <id>https://jyzhu.top/%E8%AF%BB%EF%BC%9A%E8%AE%BA%E8%A7%86%E8%A7%89%E7%9F%A5%E8%AF%86/</id>
    <published>2021-12-15T06:25:17.000Z</published>
    <updated>2021-12-15T06:29:43.189Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：https://link.springer.com/article/10.1631%2FFITEE.1910001</p><p>作者：潘云鹤</p><p>发表： Frontiers of Information Technology &amp; Electronic Engineering</p><p>链接： https://link.springer.com/article/10.1631%2FFITEE.1910001</p><hr /><blockquote><p>这篇是潘院士的前瞻性思考，虽然比较短，但还是认真读一读。学长分享给我，大概是可以对我们的研究起到一些指导性启迪吧。</p></blockquote><h2 id="why">Why：</h2><h2 id="what">What：</h2><ol type="1"><li>提出“视觉知识”概念</li><li>视觉概念-&gt;视觉命题-&gt;视觉叙事</li></ol><p>读前疑问：</p><h2 id="how">How：</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文地址：https://link.springer.com/article/10.1631%2FFITEE.1910001&lt;/p&gt;
&lt;p&gt;作者：潘云鹤&lt;/p&gt;
&lt;p&gt;发表： Frontiers of Information Technology &amp;amp; Electronic Engineering&lt;/p&gt;
&lt;p&gt;链接： https://link.springer.com/article/10.1631%2FFITEE.1910001&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Computer Vision" scheme="https://jyzhu.top/tags/Computer-Vision/"/>
    
    <category term="Paper Reading" scheme="https://jyzhu.top/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>Check My Evangelion Theme for Typora!!</title>
    <link href="https://jyzhu.top/Check-My-Evangelion-Typora-Theme/"/>
    <id>https://jyzhu.top/Check-My-Evangelion-Typora-Theme/</id>
    <published>2021-12-14T15:13:21.000Z</published>
    <updated>2021-12-18T18:27:38.729Z</updated>
    
    <content type="html"><![CDATA[<p>Heeeeyyyyy!!! I customized a theme called <code>Evangelion</code> for <strong><a href="https://typora.io/">Typora</a> Markdown Editor</strong>, and it was accepted! Do check it on the <a href="https://theme.typora.io/theme/Evangelion/">Typora - Theme official page</a>:</p><figure><img src="https://s2.loli.net/2021/12/14/1AX7Bkra6loxWcR.png" alt="The first one is mine" /><figcaption>The first one is mine</figcaption></figure><figure><img src="https://s2.loli.net/2021/12/14/kNT6uZ2MhrDPSHx.png" alt="Offical page" /><figcaption>Offical page</figcaption></figure><p>And the theme's homepage is here: <a href="https://github.com/viridityzhu/Evangelion-typora-theme" class="uri">https://github.com/viridityzhu/Evangelion-typora-theme</a></p><p>Get downloads: <img src="https://img.shields.io/github/downloads/viridityzhu/Evangelion-typora-theme/total.svg" /></p><p>(People just download, but don't give me a star T^T)</p><h1 id="evangelion-typora-theme">Evangelion-typora-theme</h1><p>An eye-friendly dark theme for <a href="https://typora.io/">Typora</a> Markdown Editor, based on the color scheme of Neon Genesis Evangelion.</p><figure><img src="https://theme.typora.io/media/theme/evangelion/eva0.png" alt="Image of Evangelion found from Google" /><figcaption>Image of Evangelion found from Google</figcaption></figure><h2 id="feature">Feature</h2><ul><li>Supports <strong>English</strong> and <strong>中文</strong>.</li><li>Eye-friendly <strong>dark mode</strong>.</li><li>Code color scheme imported from <a href="https://codemirror.net/theme/material-ocean.css">material-ocean</a>.</li><li><em>I love Evangelion Unit-01!</em></li></ul><h2 id="screenshots">Screenshots</h2><figure><img src="https://theme.typora.io/media/theme/evangelion/eva1.png" alt="套娃现场" /><figcaption>套娃现场</figcaption></figure><div><p float="left"><img src="https://theme.typora.io/media/theme/evangelion/eva2.png" width="49%" style="display:inline !important"/> <img src="https://theme.typora.io/media/theme/evangelion/eva3.png" width="49%" style="display:inline !important"/></p></div><h2 id="install">Install</h2><ul><li>Download the <code>Eva.css</code> file: see <a href="https://github.com/viridityzhu/Evangelion-typora-theme/releases">releases</a>.</li><li>Copy and paste the file in to the <strong>Typora Theme Folder</strong>:<ul><li><code>Preferences…</code> &gt; <code>Appearence</code> &gt; <code>Open Theme Folder</code>.</li></ul></li><li>Restart Typora, then select <code>Theme</code> &gt; <code>Eva</code> to apply.</li></ul><p>安装：</p><ul><li>下载<code>Eva.css</code>文件: <a href="https://github.com/viridityzhu/Evangelion-typora-theme/releases">releases</a></li><li>将该文件粘贴到<strong>Typora主题文件夹</strong>中：<ul><li><code>偏好设置</code> &gt; <code>外观</code> &gt; <code>打开主题文件夹</code></li></ul></li><li>重启Typora，然后选择<code>主题</code> &gt; <code>Eva</code>，主题即可生效。</li></ul><h2 id="reference">Reference</h2><p>I take the color palette of <a href="https://en.wikipedia.org/wiki/Neon_Genesis_Evangelion">Neon Genesis Evangelion</a>.</p><p>And this theme code is inspired by both <a href="https://github.com/imageslr/typora-theme-bear">bear-dracula</a> and <a href="https://github.com/Y1chenYao/typora-mint-theme">mint-dark</a>. I love these 2 themes, too!</p><p><em>Designed and tested on macOS. Not fully tested, but should work for Windows/Linux.</em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Heeeeyyyyy!!! I customized a theme called &lt;code&gt;Evangelion&lt;/code&gt; for &lt;strong&gt;&lt;a href=&quot;https://typora.io/&quot;&gt;Typora&lt;/a&gt; Markdown Editor&lt;/strong&gt;, and it was accepted! Do check it on the &lt;a href=&quot;https://theme.typora.io/theme/Evangelion/&quot;&gt;Typora - Theme official page&lt;/a&gt;:&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://s2.loli.net/2021/12/14/1AX7Bkra6loxWcR.png&quot; alt=&quot;The first one is mine&quot;&gt;&lt;figcaption&gt;The first one is mine&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;https://s2.loli.net/2021/12/14/kNT6uZ2MhrDPSHx.png&quot; alt=&quot;Offical page&quot;&gt;&lt;figcaption&gt;Offical page&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;And the theme&#39;s homepage is here: &lt;a href=&quot;https://github.com/viridityzhu/Evangelion-typora-theme&quot; class=&quot;uri&quot;&gt;https://github.com/viridityzhu/Evangelion-typora-theme&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Typora" scheme="https://jyzhu.top/tags/Typora/"/>
    
    <category term="Theme" scheme="https://jyzhu.top/tags/Theme/"/>
    
    <category term="Evangelion" scheme="https://jyzhu.top/tags/Evangelion/"/>
    
  </entry>
  
  <entry>
    <title>阅读总结与别无所指</title>
    <link href="https://jyzhu.top/On-Reading-in-November/"/>
    <id>https://jyzhu.top/On-Reading-in-November/</id>
    <published>2021-12-01T16:01:41.000Z</published>
    <updated>2021-12-14T15:57:21.220Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/12/02/Hf8gyxVdShTbzCO.png" alt="我的微信读书11月阅读时长" style="zoom: 33%;" /></p><p>11月平均每日阅读43分钟，最高一天阅读4小时，总共21个小时。这意味着，这30天里，我大约有一整天的人生活在书里的世界。幸甚至哉！</p><p>这些时间最大头还是花在了<a href="https://jyzhu.top/2021/11/27/After-Reading-The-Wind-Up-Bird-Chronicle-by-Murakami-Haruki/">《奇鸟行状录》里（不太值）</a>，其次应该是钱钟书的《宋诗选注》和黑格尔的《小逻辑》里。看上去好奇怪的组合，不过不然。这其实很符合我的阅读习惯，一般是不同类型的书同时阅读，每次依当天的状态和心情去择一本翻开。实际上，想读《小逻辑》的时候，和想读《奇鸟行状录》的时候，整个人的状态是完全不一样的。据我观察，当我精神状态极佳、心情大好的时候，最想读哲学类的书；情感泛滥（高涨或者低落）的时候，最想读诗；感到疲乏的时候，想读小说来消遣。我倒也根据这么一点小习性，大言不惭地自觉“随性”，除了读书随心所欲以外，生活中大大小小的事上，心态也大抵类似。（主要是小事，大事实际上还是有点优柔寡断的，还想改呢。）</p><p>不过呢，这个月挑来读的这几本书，跟我之前的阅读惯性相比还是比较突兀的。一方面，小说上，我已经挺久没读日本小说了。虽然以前也喜欢村上春树，但这次是带着一些“怀旧”的心情去读他的。根据我的规划，在这个人生阶段，我是想读一些陀氏和海明威的，再往后也想涉猎一些不太熟悉但十分严肃的作家。</p><p>另一方面，这是我头一次迈入哲学原著的门🚪，精挑细选之后，才决定从黑格尔读起：人们说黑格尔是最后一个拥有完整的大哲学体系的哲学家；人们还说要想真的了解哲学，首先应该好好了解黑格尔。另外，黑格尔的辩论法，是想了解后世大多数哲学家，绕不过的一个话题。至于选择《小逻辑》，纯粹是贪图它比较短小精悍，但也完整包含了黑格尔整个逻辑学的思想，想来比较容易上手……然而读起来也不枉“晦涩”一词。我读得确实缓慢，但只要是一眼小小的泉眼，也总会源头活水慢慢来的。</p><p>宋诗嘛，是头脑一热想读古诗试试。之前喜欢的是现代诗，对古诗颇感敬畏。读起来其实很有趣，我以前对古诗的印象，是觉得所有诗都主题雷同，用的意象翻来覆去那几个。但捧起读来，才能真的体会到个中妙处。就是那么一板一眼的格律，那么受限的意象，那么几个主题，然每首诗都有实在的新意。我发现我渐渐开始喜欢起写景的诗来。</p><p>在新加坡这永无止境的夏季中，我心之所向的莫过于这样的场景了——</p><blockquote><p>嘉果浮沉酒半醺，床头书册乱纷纷。</p><p>北轩凉吹开疏竹，卧看青天行白云。</p><p>-- 苏舜钦《暑中闲咏》</p></blockquote><p>另外，读到一个有趣的诗人李觏，钱钟书说他写诗喜欢用独特的意象和“特立独行”的字。听上去这个评价并不是特别褒义，我倒是意外很喜欢。</p><blockquote><p>人言落日是天涯，望极天涯不见家；</p><p>已恨碧山相阻隔，碧山还被暮云遮！</p><p>-- 李觏《乡思》</p></blockquote><p>这种蕴含奇思的诗，可能美感会被削弱，但是灵气却是独具，是我所偏爱！</p><p>还有一位跟他评价相近的诗人王令，他的这首《暑旱苦热》是我目前印象最深的。天哪，一首诗难道不就是要体现诗人“手提天下”这样的意致纵横吗！</p><blockquote><p>清风无力屠得热，落日着翅飞上山。</p><p>人固已惧江海竭，天岂不惜河汉干？</p><p>昆仑之高有积雪，蓬莱之远常遗寒。</p><p><strong>不能手提天下往，何忍身去游其间？</strong></p><p>-- 王令《暑旱苦热》</p></blockquote><hr /><p>我人生的阅读量高峰，集中在高中三年，不长不短。大学以来，整个人“务实”了许多，大多数时间分给了小时候心目中“没有意义”的琐碎生活。这是有意义的。不过因为记忆能力的缺憾，我整个就好像一个虽然读写速度快，但容量很低的内存（我也不想混入这么奇怪的计算机比喻啊喂(#`O′)）……见什么东西，理解很快，忘得也很快。今天刚跟小熊凄惨地对了一下去年看的JOJO第四季的人物关系，发现我的记忆已经完全模糊混乱了。所以嘛，大部分读过的书，到最近一两年，几乎已经面目模糊了。我在想，有的书与我的关系可能已经衰退到了 听到书名时知道这本我读过 的地步，虽然我发誓我读每本书的时候都很认真（还很慢）。</p><p>以前在知乎上刷到“读过的书还是会忘记，那么读书到底有什么意义”这类问题，还会饶有兴致地点开认真看；现在看到倒是觉得看得明白了。要我回答的话，我认为这个问题本身是不成立的。问读书对人的意义在哪，不是和问“郊游”对人的意义在哪一样嘛。我能理解那种功利性的想法，把读书和学一门特长类比，希望带来一些价值；但我想这类想法都涉嫌自指，即一种逻辑上的悖论，是不成立的。（其实我很不喜欢“特长”这个词，因为它是功利性的；“兴趣”这个词才本质嘛。）</p><p>生活的目的（而不是意义）就是生活，再往后一步别无所指。我每日学习，阅读，喝酒（不是真的每天喝酒），晒太阳，这些事情的目的是什么呢？就是为了学习，阅读，喝酒，晒太阳呀！（去码头整点薯条笑话就是最准确的表达。）</p><p>想起来上次妈妈分享的一个有关性格、品质的心理学测试，测出来好多好多个评价维度，其中我最低的两项是什么“希望”“活力”，给我整挺乐的。那些问题问出来，按我的想法，选的确实都是最显得悲观的答案；但是这好像没法评价我这类荒诞主义<strong>信仰</strong>啊（瞎造了一个词）。虽然听上去很没有活力，但恰恰是超级有活力的！只不过望穿人生舞台的布景，直面整个荒诞而已，这不是对生活真正的热爱吗？</p><p>跟我心境最相近的毫无疑问是苏轼这一首词，我的最爱，没有之一：</p><blockquote><p>落日绣帘卷，亭下水连空。知君为我新作，窗户湿青红。</p><p>长记平山堂上，欹枕江南烟雨，杳杳没孤鸿。认得醉翁语，“山色有无中”。</p><p>一千顷，都镜净，倒碧峰。<strong>忽然浪起，掀舞一叶白头翁。</strong></p><p>堪笑兰台公子，未解庄生天籁，刚道有雌雄。<strong>一点浩然气，千里快哉风。</strong></p><p>-- 苏轼《水调歌头·黄州快哉亭赠张偓佺》</p></blockquote><p>我觉得人生诗意（或者一般语境中的意义），不说全部，至少一半都在这一句中了吧：“忽然浪起，掀舞一叶白头翁。”哈哈哈哈，解释不明白。</p><p>我其实最近才承认自己热爱生活。之前也确实中了常规思路的桎梏，觉得自己是消极悲观的。可是我方才自觉是极热爱生活的。就好像热爱一些自由度高的沙盒游戏，或者决策系统很复杂的策略游戏一样，我也热爱兼具这两种特性的生活，热爱生活的这两种特性。不过由于一些理科生的科学主义<strong>信仰</strong>，我倒是保有这样一种偏颇的理想：好想通过建模和参数来解释甚至预测整个世界啊哈哈哈。</p><p>最后再自己跟自己（因为大概没有别人会看吧）解释一下前文几处加粗的“<strong>信仰</strong>”二字的额外含义。其实只是一种疑心，既怀疑我对这些思想的理解之正确性，也怀疑这些思想本身的正确性。进一步来说，一方面意味着我仍然没有把这里写的任何东西当真，认为这些都有可能是错误的，并且可能会被之后的我推翻。另一方面，也意味着正如破除对“意义”的幻想一样，我当然也破除了对所有思想的幻想。再赘述一句，这类幻想的破除并不是消极的，而是勇敢的。是对应那句：</p><blockquote><p>我要的不是岸，我要海浪翻卷。</p></blockquote><p>写得也太零碎了，但能藉由阅读这个主题，把我最近这些细碎的想法一股脑说出来，倒也畅快。只是行文不得不说是坑坑洼洼，离我想达到的表达水平差远了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/12/02/Hf8gyxVdShTbzCO.png&quot; alt=&quot;我的微信读书11月阅读时长&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;11月平均每日阅读43分钟，最高一天阅读4小时，总共21个小时。这意味着，这30天里，我大约有一整天的人生活在书里的世界。幸甚至哉！&lt;/p&gt;
&lt;p&gt;这些时间最大头还是花在了&lt;a href=&quot;https://jyzhu.top/2021/11/27/After-Reading-The-Wind-Up-Bird-Chronicle-by-Murakami-Haruki/&quot;&gt;《奇鸟行状录》里（不太值）&lt;/a&gt;，其次应该是钱钟书的《宋诗选注》和黑格尔的《小逻辑》里。看上去好奇怪的组合，不过不然。这其实很符合我的阅读习惯，一般是不同类型的书同时阅读，每次依当天的状态和心情去择一本翻开。实际上，想读《小逻辑》的时候，和想读《奇鸟行状录》的时候，整个人的状态是完全不一样的。据我观察，当我精神状态极佳、心情大好的时候，最想读哲学类的书；情感泛滥（高涨或者低落）的时候，最想读诗；感到疲乏的时候，想读小说来消遣。我倒也根据这么一点小习性，大言不惭地自觉“随性”，除了读书随心所欲以外，生活中大大小小的事上，心态也大抵类似。（主要是小事，大事实际上还是有点优柔寡断的，还想改呢。）&lt;/p&gt;
&lt;p&gt;不过呢，这个月挑来读的这几本书，跟我之前的阅读惯性相比还是比较突兀的。一方面，小说上，我已经挺久没读日本小说了。虽然以前也喜欢村上春树，但这次是带着一些“怀旧”的心情去读他的。根据我的规划，在这个人生阶段，我是想读一些陀氏和海明威的，再往后也想涉猎一些不太熟悉但十分严肃的作家。&lt;/p&gt;</summary>
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>After Reading The Wind-Up Bird Chronicle by Murakami Haruki</title>
    <link href="https://jyzhu.top/After-Reading-The-Wind-Up-Bird-Chronicle-by-Murakami-Haruki/"/>
    <id>https://jyzhu.top/After-Reading-The-Wind-Up-Bird-Chronicle-by-Murakami-Haruki/</id>
    <published>2021-11-27T14:29:05.000Z</published>
    <updated>2021-11-27T14:45:26.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读后感">读后感</h2><blockquote><p>在<em>微信读书</em>上花了整整22个小时读了<a href="https://en.wikipedia.org/wiki/The_Wind-Up_Bird_Chronicle">《奇鸟行状录》</a>，感受不佳，读完的时候甚至感到愤懑，胡说一通。</p></blockquote><p>读完我竟然有生气的感觉。尤不喜欢这个隐喻大乱炖式结尾。早知道这本小说通篇暗喻，一件事也没直接地、好端端地讲明白，我是断不会选择阅读的。生气大概是对我这二十多个小时感到不值。</p><p>我从来不讨厌隐喻，过去也从村上的《海边的卡夫卡》《挪威的森林》之类长篇里收获了村上式魔幻现实的趣味，也因此是喜欢村上春树的。</p><p>但是，不一样的地方在于，本书是所谓「村上春树转型之作」，开始触及更严肃、更宏大的议题，我原本也是对此颇有期待的。可是用他特有的轻飘飘的方式来探讨爱情、人生我尚能接受，照样探讨暴力、战场，我只有不理解。（剥皮那一段写得倒是很沉重，也很好。）</p><p>我认为隐喻该是为了更清楚、更深刻的表达而存在的，而这本书里的大量隐喻根本无益于表达。本书最大的一个主题，即暴力会以各种形式对人造成损害，完全是有更直截了当的方式可以表达清楚的，我一直在期待更直白深入的探讨。可是整本书被细枝末节的、含义不明的隐喻占据了篇幅，以悬疑的情节、跌宕的故事走向来吸引人，我只觉得是挂羊头卖狗肉。</p><p>无语凝噎。</p><h2 id="读中感">读中感</h2><p>这段时间在读村上春树的《奇鸟行状录》。我感觉还行，但是有一点不喜欢的地方。当然是会读完的，都读了三分之二了；但是容我在此吐吐槽吧。不喜欢的地方就是那种神神叨叨，老是说梦境与现实有联系、无法区分啊，老是说主角有什么样什么样的命运，然后遇到一些世外奇人，身上发生一些象征意义的变化，然后命运就哦豁转向了。命运之前是什么方向，后来又是什么方向呢？主角确实有感觉，但又道不明，不可说。总结起来就是：神神叨叨。看别人的想法的时候，有一个人提到村上说话总是有一股刻意的淡定、简短感，他又让笔下所有人都这样说话，导致所有人都有一股村上感，说的都不大像人话，也不一定符合人物性格了。太贴切了！</p><p>我想这本书读罢，我大概会搁置村上春树的作品们了。大概是又长大些了吧，阅读口味总之是变化了。下一本肯定会读陀氏的。</p><hr /><p>或许是我举一反三能力有限…有很多寓言性质的东西，我并没有找出来与之对应的现实意义的道理，并没有完全理解村上想表达的含义。</p><p>妻子有暗处的无人察觉的一面，妻子在某种超现实的意义上受困；作为与妻相爱的丈夫，冈田需要从一开始失去妻子的迷茫和失落中走出来，坚持自己，把这当成使生活停滞的磨难，想办法救回妻子，让生活步入正轨，给自己所处的世界重新拧上发条……可是现实生活—至少是我的现实生活，不是这么运转的呀，没有这样的形式呀？</p><p>一个地道的人，做出的事总是不那么地道、很令人意外；一个人渐渐地就滑入了一个与常人的世界不同的、仿佛停滞了的世界。这是怎样的一种人生困境呢？</p><p>书中冈田无法接受妻子和情人跑了的事实，很努力地思考、寻找答案，然后通过一些超现实的隐喻和境遇，还真的发现了妻子遇到了只有自己才能挽救的困境这一事实。可是现实生活中，更多时候，发生这种不遂人意的事，更大概率那就是事实吧，把自己放在井底枯想，只会想疯了，不会想通了吧？</p><h2 id="傻里傻气的雨蛙女儿从笠原may身上唯一感怀到的">傻里傻气的雨蛙女儿——从笠原May身上唯一感怀到的</h2><blockquote><p>最近我暗暗觉得好笑：人们这样从早到晚忙得不亦乐乎有点怪。没这样想过？怎么说好呢，我在这里的工作，只不过按头头如此这般的吩咐如此这般地干罢了，丝毫用不着动脑，等于说脑浆那东西上工前放在寄存柜里下工时再随手拿回。一天七小时对着操作台一个劲儿往发罩上栽头发，然后在食堂吃饭进浴室洗澡，接下去当然就得像一般人那样睡觉。一天二十四小时可自由支配的时间实在少得可怜，而且“自由时间”也由于人困马乏而多用来打瞌睡或怔怔发呆，几乎谈不上用心想点什么。当然周末不用做工，却又要集中洗衣服搞卫生。有时还要上街，一忽儿就过去了。一次曾下决心写写日记，但简直没什么好写，只一周就扔一边去了。日复一日千篇一律嘛！ 尽管这样，尽管这样，对于自己如此成为工作的一部分我还是半点厌恶情绪都没有，别扭感什么的也没有。或者不如说由于这样蚂蚁式地一门心思劳动，我甚至觉得渐渐靠近了“本来的自己”。怎么说呢，说倒说不好，总之好像是由于不思考自己而反倒接近自己的核心。我所说的“有点怪”就是这个意思。</p></blockquote><p>唉，我还没有长大（或者说还没有和解）的一点是什么呢，就是无论自己做什么，都还在担心没有在做「正确」的事情，担心虚耗时间，担心一头栽进什么洞里似的。</p><blockquote><p>那两人居然相信世界是如同单元住宅那样始终一贯如此这般的，以为只要以始终一贯的方法干下去，一切终将水到渠成，所以他们也才为我的倒行逆施而困惑而伤心而气恼。</p></blockquote><p>其实笠原may就是加缪笔下的荒诞人，觉察了世界如同舞台布景，一旦坍塌背后什么也不是。这里她所谓雨蛙一般的父母，就是从来没有过从自己扮演的角色中抽离出来，从来没有停下来反思过的平凡人罢</p><h2 id="有关拧发条鸟的比喻又及为什么要翻译成奇鸟行状录呢">有关「拧发条鸟」的比喻；又及，为什么要翻译成「奇鸟行状录」呢？</h2><blockquote><p>&quot;拧发条鸟是实际存在的鸟。什么样我不知道，我也没亲眼见过，只听过叫声。拧发条鸟落在那边树枝上一点一点拧世界发条，‘吱吱吱吱’拧个不停。如果它不拧发条，世界就不动了。但这点谁也不晓得，世上所有的人都以为一座远为堂皇和复杂的巨大装置在稳稳驱动世界，其实不然，是拧发条鸟飞到各个地方，每到一处就一点点拧动小发条来驱动世界。发条很简单，和发条玩具上的差不多，只消拧发条即可，但那发条唯独拧发条鸟方能看到。&quot;</p></blockquote><p>这个比喻没有打动我。我眼中的世界比这个精巧多了。不过比喻本身还是很精彩的</p><blockquote><p>但是，无论是不是偶然的一致，在肉桂的故事中“拧发条鸟”这一存在都不可漠视。人们在它那只有特殊人方可听见的鸣声引导下走向无可回避的毁灭。在那里，一如兽医自始至终感觉的那样，所谓人的自由意志等等是无能为力的。他们像被上紧背部发条而置于桌面的偶人，只能从事别无选择余地的行为，只能朝别无选择余地的方向前进。处于听到鸟鸣范围内的人们，几乎人人都遭受剧烈磨损以至消失。大部分人死掉了，他们直接从桌边滚到了地下。</p></blockquote><p>这才理解到村上比喻的准确。「拧发条」是被动而不是主动，是别无选择、剧烈磨损、走向毁灭。</p>]]></content>
    
    
    <summary type="html">我认为隐喻该是为了更清楚、更深刻的表达而存在的，而这本书里的大量隐喻根本无益于表达。</summary>
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
    <category term="Literature" scheme="https://jyzhu.top/tags/Literature/"/>
    
  </entry>
  
  <entry>
    <title>Houses with open doors</title>
    <link href="https://jyzhu.top/Houses-with-open-doors/"/>
    <id>https://jyzhu.top/Houses-with-open-doors/</id>
    <published>2021-11-27T14:23:00.000Z</published>
    <updated>2021-11-27T14:23:41.552Z</updated>
    
    <content type="html"><![CDATA[<p>互联网冲浪对于我来说最浪漫的事情之一，就是顺着一篇搜来的技术文档，随手点开博客主页时，发现博客中记满了朴素但真挚的生活感想。有哲思，有小故事，有少年得意的成就记叙，也有人到中年的感怀伤时……每个人的博客都是独一无二的，网站名字和独特装饰极力彰显着个性；但所有博客又有一个共同的特点，就是毫无保留的文字和期待被造访的心情。这就好像在漠然的大城市里，却有一些不起眼的小屋子，真诚地敞着所有的门窗，等待像我这样的，可能会来，也可能不会来的旅人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互联网冲浪对于我来说最浪漫的事情之一，就是顺着一篇搜来的技术文档，随手点开博客主页时，发现博客中记满了朴素但真挚的生活感想。有哲思，有小故事，有少年得意的成就记叙，也有人到中年的感怀伤时……每个人的博客都是独一无二的，网站名字和独特装饰极力彰显着个性；但所有博客又有一个共同</summary>
      
    
    
    
    <category term="thoughts" scheme="https://jyzhu.top/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>Data Structures and Their ADTs</title>
    <link href="https://jyzhu.top/Quick-Notes-About-Data-Structures/"/>
    <id>https://jyzhu.top/Quick-Notes-About-Data-Structures/</id>
    <published>2021-11-03T12:05:53.000Z</published>
    <updated>2021-12-04T00:52:01.951Z</updated>
    
    <content type="html"><![CDATA[<p>In IT5003, I am studying data structures and algorithms. The language we learn with is Python. So I take notes about what I learned, and how to use them in Python. I struct my notes based on data structures, and all the ADTs that are implemented by the data structures are discussed within. I focus on their usage, key design, and sometimes problems. In the future maybe I will append all the implementation codes.</p><hr /><ul><li>ADT: Abstract data type, from the point of view of a user, defined by its behavior.</li><li>Data Structure: from the point of view of an implementer, concrete representations of data.</li></ul><h1 id="linear-data-structures">Linear Data Structures</h1><h2 id="array">Array:</h2><blockquote><p>Continuous space to store fix-sized elems.</p></blockquote><p>I often confuse array with list... Now I need to clarify that an <strong>array</strong> is a data structure, which is one of the implementations of the <strong>List ADT</strong>.</p><p><strong>Key design</strong>:</p><p>Methods:</p><ul><li>==Get ith==: O(1) obviously at A[i]</li><li>==Insert(i)==: O(n) worst/average, coz need to shift left; O(1) if insert at tail</li><li>==Remove(i)==: Just similar as insert, need to shift right.</li><li>==Search n==: Still similar. O(n) worst/average found at tail; O(1) if found immediately at head</li></ul><p><strong>Usage</strong>: Make a <strong>List ADT</strong>. Store ordered things continually, we can <strong>insert</strong> into a specific position, <strong>get</strong> ith element, of course also <strong>search</strong>, and <strong>remove</strong></p><p><strong>Problem</strong>: Insert and remove are <strong>O(n)</strong> coz it needs to shift everything behind to make the position empty/not empty. Also, it requires <strong>consecutive</strong> and <strong>fixed</strong>(can be overcome) space to store, sometimes may be not that flexible.</p><p><strong>In python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># It is PYTHON who let me confuse the 2!! coz in python, an array is just called a list...</span></span><br></pre></td></tr></table></figure><h2 id="linked-list">Linked List</h2><blockquote><p>non-continous space, not fixed-size. Each vertex contains value and a pointer pointing next vertex.</p></blockquote><p><strong>Usage</strong>: Make a <strong>List ADT</strong> again. Compared with an array, it doesn't need to be consecutive and fixed-size, and it can <strong>insert</strong>/<strong>remove</strong> from <strong>head</strong> very efficiently, in <strong>O(1)</strong>. But most importantly, it can make <strong>Stack/Queue/Deque ADT</strong>, because it is <strong>resizeable</strong>.</p><p><strong>Key Design</strong>: I think just need to clarify its attributes and methods:</p><ul><li>Attributes:<ul><li>Value</li><li>Next -- Singly LL</li><li>(Previous -- Doubly LL)</li></ul></li><li>Methods:<ul><li>==Get ith==: Unfortunately it becomes <strong>O(n)</strong> compared with array, coz it needs to go from the head pointer.</li><li>==Insert==: Insert at the head only need <strong>O(1)</strong> (at tail also O(1) if it is doubly linked); but on average, also <strong>O(n)</strong>, coz should go from head :(</li><li>==Remove==: Just similar as insert. (ps: coz need to search the prev node)</li><li>==Search n==: Obviously O(1) best and <strong>O(n)</strong> worst/avg, same as Array</li></ul></li></ul><h3 id="stack-adt">Stack <strong>ADT</strong></h3><blockquote><p>Like book stack.</p></blockquote><p><strong>Usage</strong>: <strong>LIFO</strong>(last-in-first-out), so you can both <strong>pop</strong> and <strong>push</strong> from head. (Errrr, impacted by python, I always think of it as a tail).</p><p><strong>In python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># just use a list!! and regard the tail as the head.</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">1</span>)</span><br><span class="line">lastElem = stack.pop() <span class="comment"># by default, pop at -1, i.e. the last one</span></span><br></pre></td></tr></table></figure><h3 id="queue-adt">Queue <strong>ADT</strong></h3><blockquote><p>Like queue in reality.</p></blockquote><p><strong>Usage</strong>: <strong>FIFO</strong>(first-in-first-out), so <strong>push</strong> at the tail and <strong>pop</strong> from head, it is perfectly implemented by a <strong>linked list</strong> (with tail pointer), to make both operations <strong>O(1)</strong>.</p><p><strong>In python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment"># coz queue is a subset of deque, so a deque can be a queue, haha</span></span><br><span class="line">q = deque()</span><br><span class="line">q.append()</span><br><span class="line">q.popleft()</span><br></pre></td></tr></table></figure><h3 id="deque-adt">Deque <strong>ADT</strong></h3><blockquote><p>Queue + double head</p></blockquote><p><strong>Usage</strong>: Double-ended queue. Both <strong>pop</strong> &amp; <strong>push</strong> from both <strong>head</strong> &amp; <strong>tail</strong>. Perfectly implemented by a <strong>doubly linked list</strong>, with all operations <strong>O(1)</strong>.</p><p><strong>In python</strong>: Look at Queue.</p><h1 id="non-linear-data-structures">Non-Linear Data Structures</h1><h2 id="binary-heap">Binary Heap</h2><blockquote><p><strong>Complete Binary Tree</strong>: Every level fully filled + last level as far left as possible</p><p>+ <strong>Binary Max Heap property</strong>: Parent greater than children</p></blockquote><p><strong>Usage</strong>:</p><p>Used for implementing a <strong>Priority Queue ADT.</strong> When to use PQ? When you need to maintain some ordered elements, and frequently fetch the Max/Min ones.</p><p><strong>Key Design</strong>: A binary heap is firstly a <strong>binary tree</strong>, and then it is ruled as a <strong>Min heap</strong> -- every parent node should be smaller than its 2 children. The direct way of implementing the binary heap is to use Tree class, with attributes Value, LeftChild and RightChild. However, it is more convenient if we just simply use an <strong>array</strong>. Just need to think of this:</p><ul><li>For a parent at kth position, its left child is at <span class="math inline">\(k * 2\)</span>, and right child is k * 2 + 1.</li><li>For a child at kth position, its parent is at k//2.</li><li>For a condensed binary tree, everything can be mapped into an also condensed list.</li></ul><p>5 standard Binary (Max) Heap operations:</p><ol type="1"><li>==<strong>Insert(v)</strong>== in O(log <strong>N</strong>): Firstly insert as the last leaf. Then <strong>bubble up</strong> -- obviously, swap from the bottom to the up.</li><li>==<strong>ExtractMax()</strong>== in O(log <strong>N</strong>): just get the root element; then the important thing is what you should do after popping out the root element -- you need to maintain the heap. So, pick the last leaf to the root, then <strong>bubble down</strong> -- i.e. swap the parent with the bigger child up to down, till all fine.</li><li>(==<strong>Create(A)</strong>== - O(<strong>N</strong> log <strong>N</strong>) version: Simply insert (that is, by calling <strong>Insert(v)</strong> operation) all <strong>N</strong> integers of the input array into an initially empty Binary Max Heap one by one.)</li><li>==<strong>Create(A)</strong>== - O(<strong>N</strong>) version: (make a list of unsorted elements become a heap): best is <strong>O(n)</strong>, with bubble up the leaves.</li><li>==<strong>HeapSort()</strong>== - in O(<strong>N</strong> log <strong>N)</strong>: Simply call the O(log <strong>N</strong>) <strong>ExtractMax()</strong> operation <strong>N</strong> times.</li></ol><p><strong>Extra</strong>: Heapsort is not <strong>cache friendly</strong>. Because the computer will predict that you'll read the array in sequence, so it will cache the following elems. Quicksort takes this advantage. Mergesort not.</p><p><strong>In python</strong></p><p>Implementation: don't use it, just for understanding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_heap</span>:</span>  <span class="comment"># implementation that has no duplicate</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># the underlying data structure, we will ignore index 0</span></span><br><span class="line">        self.A = [<span class="literal">None</span>]</span><br><span class="line">    <span class="comment"># three helper navigation function, all O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parent</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> i // <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shift_up</span>(<span class="params">self, i</span>):</span>  <span class="comment"># O(log n)</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># at root, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> self.A[i] &gt; self.A[self.parent(i)]:  <span class="comment"># violate property with parent</span></span><br><span class="line">            self.A[i], self.A[self.parent(i)] = self.A[self.parent(i)], self.A[</span><br><span class="line">                i]  <span class="comment"># swap upwards</span></span><br><span class="line">            <span class="comment"># recurse, at most O(log n) steps back to the root</span></span><br><span class="line">            self.shift_up(self.parent(i))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, x</span>):</span>  <span class="comment"># O(log n)</span></span><br><span class="line">        <span class="comment"># append to the back of Python list, the only possible insertion point,</span></span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        self.shift_up(<span class="built_in">len</span>(self.A) - <span class="number">1</span>)  <span class="comment"># shift upwards, O(log n) at worst</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shift_down</span>(<span class="params">self, i</span>):</span>  <span class="comment"># O(log n)</span></span><br><span class="line">        swap_id = i</span><br><span class="line">        <span class="comment"># compare with left child, if exists</span></span><br><span class="line">        <span class="keyword">if</span> self.left(i) &lt; <span class="built_in">len</span>(self.A) <span class="keyword">and</span> self.A[i] &lt; self.A[self.left(i)]:</span><br><span class="line">            swap_id = self.left(i)</span><br><span class="line">        <span class="comment"># compare with right child, if exists</span></span><br><span class="line">        <span class="keyword">if</span> self.right(i) &lt; <span class="built_in">len</span>(self.A) <span class="keyword">and</span> self.A[swap_id] &lt; self.A[self.right(i)]:</span><br><span class="line">            swap_id = self.right(i)</span><br><span class="line">        <span class="keyword">if</span> swap_id != i:  <span class="comment"># need to swap with the larger of the two children</span></span><br><span class="line">            <span class="comment"># swap downwards with the larger of the two children</span></span><br><span class="line">            self.A[i], self.A[swap_id] = self.A[swap_id], self.A[i]</span><br><span class="line">            <span class="comment"># recurse, at most O(log n) steps to one of the bottom-most leaf</span></span><br><span class="line">            self.shift_down(swap_id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_max</span>(<span class="params">self</span>):</span>  <span class="comment"># O(log n)</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        taken = self.A[<span class="number">1</span>]  <span class="comment"># this is the maximum value, O(1)</span></span><br><span class="line">        <span class="comment"># swap with the last existing leaf, O(1)</span></span><br><span class="line">        self.A[<span class="number">1</span>], self.A[-<span class="number">1</span>] = self.A[-<span class="number">1</span>], self.A[<span class="number">1</span>]</span><br><span class="line">        self.A.pop()  <span class="comment"># reduce list size by one, O(1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="comment"># fix heap property downwards, O(log n) at worst</span></span><br><span class="line">            self.shift_down(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> taken  <span class="comment"># return the maximum value, O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_max</span>(<span class="params">self</span>):</span>  <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">1</span>]  <span class="comment"># this is the root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span>  <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.A) == <span class="number">1</span>  <span class="comment"># when A = [None] only</span></span><br></pre></td></tr></table></figure><p>Use the library:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heappush, heapify</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue <span class="comment"># implemented based on the heapq, a thread safe version</span></span><br><span class="line"></span><br><span class="line">pq_heapq = [] <span class="comment"># this is a MIN heap, to get a max heap, we negate all numbers</span></span><br><span class="line">heappush(pq_heapq, -<span class="number">5</span>)  <span class="comment"># insert negation</span></span><br><span class="line">heappop(pq_heapq)</span><br></pre></td></tr></table></figure><h2 id="hash-table">Hash Table</h2><blockquote><p>Hashing is an algorithm (via a hash function) that maps large data sets of variable length into smaller Integer data sets of a fixed length. Hash Table is a data structure to map key to values (also called Table or Map ADT).</p></blockquote><p><strong>Usage</strong>:</p><ul><li>You want a <strong>Table ADT</strong> that can store things, and you can <strong>input</strong> and <strong>search</strong> in <strong>O(1)</strong> (also <strong>delete</strong>)</li><li>Actually it's not necessarily the things are integers, they can be anything, even strings. And you can even use (key, value) pair, to store anything additionally in the value part.</li></ul><p><strong>Key design</strong>: Use a <strong>hash</strong> function to map <strong>n</strong> keys in a list with length <strong>m</strong>; then the complexity of search(v)/remove(v) is <strong>O(n/m)</strong> (Search v in the list with avg length n/m). You should design the hash function and also the length m.</p><ul><li>Hash function:<ul><li><p>For integers: <strong>modulo</strong> operation is the best practice. Just let <code>h(v) = v % M</code>. O(1).</p></li><li><p>For strings: (normally strings only contains 26 letters) <code>for char in string: sum = sum * 26 + char % 26</code>. This is like Base-26, so every English letter matters.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_function</span><span class="params">(string v)</span> </span>&#123; <span class="comment">// assumption 1: v uses [&#x27;A&#x27;..&#x27;Z&#x27;] only</span></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;                <span class="comment">// assumption 2: v is a short string</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : v) <span class="comment">// for each character c in v</span></span><br><span class="line">    sum = ((sum * <span class="number">26</span>) % M + (c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>)) % M; <span class="comment">// M is table size</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><ol type="1"><li>never modulo a constant, modulo the size of table;</li><li>never use a funtion that is not uniform, like sqrt;</li><li>never random</li></ol></li></ul></li><li>Length m:<ul><li>Based on experiences, it should be a <strong>prime</strong>, to make the least collisions; and should be around n, to make O(n/m) a constant.</li></ul></li><li>Solve collision: i.e., two or more keys have the same hash value.<ul><li><strong>Seperate Chaining</strong> (Not move): Use Doubly Linked List (or just simply python list): if 2 keys are in the same position, just add the 2nd one at the last of the list.</li><li>Opening Address (Move away):<ul><li>linear search another position</li><li>non-linear search for another position</li><li>rehash for another position</li></ul></li><li>People are debating which is better, but my teacher Steven believes SC is better.</li></ul></li><li>With these 3 operations, it is a good <strong>Table ADT</strong> (implemented by SC):<ul><li>==Search(v)==: Just check if v in A[h(v)] list. O(<span class="math inline">\(\alpha\)</span>). <span class="math inline">\(\alpha = n/m\)</span> is the avg length of each chain. If <strong>m</strong> is set properly, the <span class="math inline">\(\alpha\)</span> is then very small, thus it is O(1).</li><li>==Remove(v)==: also, coz need to search it at first. Just delete v in A[h(v)] list</li><li>==insert(v)==: O(1). Just append v in A[h(v)] list</li></ul></li></ul><p><strong>May be problems:</strong></p><ul><li>The space occupation of the hash table should be always a little bit larger than the original elements, coz it is very possible for the hash table to contain empty positions</li><li>What if the keys are duplicated? By default, we don't want it duplicated. But I believe there are potential ways to deal with duplicated keys</li></ul><p><strong>In python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># just use dictionary!!!</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">k, v = <span class="string">&#x27;zjy&#x27;</span>, <span class="number">518</span></span><br><span class="line">d[k].append(v) <span class="comment"># No need to initialize `if k not in d: d[k] = []` then</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">M = <span class="number">13</span> <span class="comment"># table size, best to be prime</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash_table</span>:</span>  <span class="comment"># mimic Python dict()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.underlying_table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash_function</span>(<span class="params">self, v</span>):</span>  <span class="comment"># for string v</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> v:</span><br><span class="line">            <span class="built_in">sum</span> = ((<span class="built_in">sum</span> * <span class="number">26</span>) % M + (<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">1</span>)) % M</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, key</span>):</span>  <span class="comment"># to emulate mapper[key]</span></span><br><span class="line">        <span class="comment"># O(k), k is the length of this list, but with careful setup, k can be</span></span><br><span class="line">        <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.underlying_table[self.hash_function(key)]:</span><br><span class="line">            <span class="keyword">if</span> k == key:  <span class="comment"># if there is an existing key</span></span><br><span class="line">                <span class="keyword">return</span> v  <span class="comment"># return this satellite data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># get the reference of the row</span></span><br><span class="line">        row = self.underlying_table[self.hash_function(key)]</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">if</span> k == key:</span><br><span class="line">                row.remove((k, v))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># we do nothing if key is not actually found</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key, value</span>):</span>  <span class="comment"># to emulate mapper[key] = value</span></span><br><span class="line">        <span class="keyword">if</span> self.search(key):</span><br><span class="line">            self.remove(key)</span><br><span class="line">        self.underlying_table[self.hash_function(key)].append(</span><br><span class="line">            (key, value))  <span class="comment"># just append at the back</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            total += <span class="built_in">len</span>(self.underlying_table[i])</span><br><span class="line">        <span class="keyword">return</span> total == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="binary-search-tree">Binary Search Tree</h2><blockquote><p>A Binary Search Tree (BST) is a binary tree in which each vertex has only up to 2 children that satisfies <strong>BST property</strong>:</p><p>All vertices in the left subtree of a vertex must hold a value smaller than its own; all vertices in the right subtree of a vertex must hold a value larger than its own.</p></blockquote><p><strong>Usage</strong>: Another way to implement <strong>Table ADT</strong>. This way, compared with hash table, it is slightly slower, with all operations <strong>O(logn)</strong>. However, it can do additional things: keep keys in table <strong>ordered</strong>.</p><p><strong>Key Design</strong>: A <strong>binary tree</strong>, for every node, everything on the left is smaller than it; on the right, bigger. (not only for the direct children, but also for everything below).</p><p>Basically, BST as an implementation of <strong>Table ADT</strong>, should also have the 3 <strong>operations</strong>: (All <strong>O(log n)</strong>)</p><ul><li>==Search(v)==</li><li>==Remove(v)==</li><li>==insert(v)==</li></ul><p>Besides, it is excellent because it has other special operations:</p><ol type="1"><li>Query operations (the BST structure remains unchanged):<ol type="1"><li>Search(v): O(h), h is the height of the tree (h is log N on average, but can be N). Just binary search from root down.</li><li>==Predecessor(v)== (and similarly ==Successor(v)==), both also O(h). (details below)</li><li>==Inorder Traversal==, then elems are sorted. O(n)</li></ol></li><li>Update operations (the BST structure may likely change):<ol type="1"><li>Insert(v), O(h), find the place and add it.</li><li>Remove(v), O(h). Worst case is that v has 2 children, then need to fisrtly search(v) in O(h), then find its successor in another O(h), then replace it by its successor, and rememer to delete the duplicated successor.</li><li>==Create BST==.</li></ol></li></ol><p>Successor后继：</p><ol type="1"><li>If v has a right subtree, should be the <strong>minimum of the right</strong></li><li>If no right subtree, go traverse ancestors, till <strong>the first ancestor that is greater</strong> than v</li><li>Otherwise, none.</li></ol><p>Presuccesor:</p><ol type="1"><li>If has a left subtree, should be the maximum of the left</li><li>If not, should be the first ancestor that is smaller</li><li>Or none.</li></ol><p><strong>Question</strong>: How many structurally different BSTs can you form with <strong>n distinct</strong> elements?</p><p><a href="https://stackoverflow.com/questions/16004723/number-of-binary-search-trees-over-n-distinct-elements">Solution with Catalan number</a></p><p><a href="http://techieme.in/count-binary-search-trees/">Solution that's more understandable</a> <span class="math display">\[Catalan_n = C_{2n}^n \div (n+1)\]</span></p><p><strong>In python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># No implemented library for binary tree</span></span><br><span class="line"><span class="comment"># If you need sorting, use `.sort()`</span></span><br><span class="line"><span class="comment"># If you need priority queue, use heapq as binary heap</span></span><br><span class="line"><span class="comment"># If you need table, use dictionary</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTVertex</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span>  <span class="comment"># set as &#x27;public&#x27; for easier coding</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__root = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__insert</span>(<span class="params">self, T, v</span>):</span>                     <span class="comment"># private version of insert</span></span><br><span class="line">        <span class="keyword">if</span> T == <span class="literal">None</span>:                             <span class="comment"># insertion point is found</span></span><br><span class="line">            T = BSTVertex(v)</span><br><span class="line">        <span class="keyword">elif</span> T.key &lt; v:                           <span class="comment"># search to the right</span></span><br><span class="line">            T.right = self.__insert(T.right, v)</span><br><span class="line">        <span class="keyword">else</span>:                                     <span class="comment"># search to the left</span></span><br><span class="line">            T.left = self.__insert(T.left, v)</span><br><span class="line">        <span class="keyword">return</span> T                                  <span class="comment"># return the updated BST</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inorder</span>(<span class="params">self, T</span>):</span>                       <span class="comment"># private version of inorder</span></span><br><span class="line">        <span class="keyword">if</span> T == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__inorder(T.left)                    <span class="comment"># recursively go to the left</span></span><br><span class="line">        <span class="built_in">print</span>(T.key, end=<span class="string">&#x27; &#x27;</span>)                     <span class="comment"># visit this BST node</span></span><br><span class="line">        self.__inorder(T.right)                   <span class="comment"># recursively go to the right</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__search</span>(<span class="params">self, T, v</span>):</span>                     <span class="comment"># private version of search</span></span><br><span class="line">        <span class="keyword">if</span> T == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> T                              <span class="comment"># not found</span></span><br><span class="line">        <span class="keyword">elif</span> T.key == v:</span><br><span class="line">            <span class="keyword">return</span> T                              <span class="comment"># found</span></span><br><span class="line">        <span class="keyword">elif</span> T.key &lt; v:</span><br><span class="line">            <span class="keyword">return</span> self.__search(T.right, v)      <span class="comment"># search to the right</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__search(T.left, v)       <span class="comment"># search to the left</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        self.__root = self.__insert(self.__root, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__inorder(self.__root)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, v</span>):</span></span><br><span class="line">        res = self.__search(self.__root, v)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res == <span class="literal">None</span> <span class="keyword">else</span> res.key</span><br></pre></td></tr></table></figure><h1 id="graph">Graph</h1><h2 id="concepts">Concepts</h2><ul><li>Vertex</li><li>Edge</li><li>Path</li><li>Directed/ Undirected</li><li>Weighted/Unweighted</li><li>Acyclic: No circle.</li><li>Connected</li></ul><p>Special Graphs</p><ul><li>Tree: only <strong>one unique path</strong> between 2 vertices. <strong>E = V - 1</strong>, always. Acyclic. Minimal edges to keep a graph connected.</li><li>Complete: <strong>E = V*(V-1)/2</strong> edges (or <strong>E</strong> = O(<strong>V2</strong>)). Most dense graph</li><li>Bipatite: can be divided into 2 sets where there is no edge between members of the same set.</li><li>DAG</li></ul><h2 id="ways-to-store-a-graph">Ways to store a graph</h2><ol type="1"><li>Adjacency Matrix: Column and row are both vertices. Space complexity <strong>O(V<sup>2</sup>)</strong><ol type="1"><li>Usage: Frequently update the weights of edges; Checking the existence of edge (u, v). Both <strong>O(1).</strong></li><li>Drawbacks: <strong>O(v)</strong> when fetch neighbors. not good when many vertices; Space complexity high.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AM = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">    AM[i] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (fh.readline().strip().split())))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Neighbors of vertex 0:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V):                             <span class="comment"># O(|V|)</span></span><br><span class="line">    <span class="keyword">if</span> AM[<span class="number">0</span>][j]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Edge 0-&#123;:d&#125; (weight = &#123;:d&#125;)&#x27;</span>.<span class="built_in">format</span>(j, AM[<span class="number">0</span>][j]))</span><br></pre></td></tr></table></figure></li><li>Adjacency List: Column is vertices, then use linked lists to store their neighbors. Space complexity <strong>O(V + E)</strong><ol type="1"><li>Usage: Commonly. Frequently fetch neighbors of vertices. <strong>O(k)</strong>, k is # nbrs. Fastest.</li><li>Drawbacks: Need to search for Existence of Edge (u, v), O(k).</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AL = defaultdict(<span class="built_in">list</span>)  <span class="comment"># initalize AL</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">    line = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (fh.readline().strip().split())))</span><br><span class="line">    total_neighbours = <span class="built_in">int</span>(line[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(line), <span class="number">2</span>):</span><br><span class="line">        v, w = <span class="built_in">int</span>(line[j]), <span class="built_in">int</span>(line[j + <span class="number">1</span>])</span><br><span class="line">        AL[i].append((v - <span class="number">1</span>, w))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Neighbors of vertex 0:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v_w <span class="keyword">in</span> AL[<span class="number">0</span>]:</span><br><span class="line">    <span class="comment"># AL[0] contains the required information</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Edge 0-&#123;:d&#125; (weight = &#123;:d&#125;)&#x27;</span>.<span class="built_in">format</span>(v_w[<span class="number">0</span>], v_w[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li><li>Edge List: Column is edges, then store pairs (vertex1, vertex2, weight). Space complexity <strong>O(E)</strong><ol type="1"><li>Usage: Need to <strong>sort</strong> edges in terms of weights</li><li>Drawbacks: Need to scan the whole thing when fetch neighbors / search existence of edge(u,v). O(E)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E = <span class="built_in">int</span>(fh.readline())</span><br><span class="line">edge_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">    u, v, w = <span class="built_in">map</span>(<span class="built_in">int</span>, fh.readline().split())</span><br><span class="line">    edge_list.append((w, u, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># build a heap</span></span><br><span class="line">heapq.heapify(edge_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># edges sorted by weight (smallest-&gt;largest)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">    edge = heapq.heappop(edge_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;weight: &#123;:d&#125; (&#123;:d&#125;-&#123;:d&#125;)&#x27;</span>.<span class="built_in">format</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></li></ol><h2 id="dfs-bfs">DFS &amp; BFS</h2><p>Both <strong>O(V + E)</strong> if the graph is implemented using Adjency List, coz we need to visit k nbrs of each v in O(k).</p><p>DFS:</p><ol type="1"><li><p>Recursion to do the visit children - visit me - loop.</p></li><li><p>Avoiding Cycle: Use an array <code>status[v]</code> of size V to remember whether a vertex is visited.</p></li><li><p>Remeber the path: Use an array <code>parent[v]</code> of size V to remember the successor of v.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPath</span>(<span class="params">u</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p[u] == -<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(u), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    printPath(p[u])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(u), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>BFS:</p><ol type="1"><li>Use a FIFO deque to do the visit all children loop.</li><li>Avoiding Cycle: Use an array <code>status[v]</code> of size V to remember whether a vertex is visited.</li><li>Visualgo said no need to track back?</li></ol><h3 id="applications">Applications</h3><ol type="1"><li><p>Reachability test: DFS/BFS, then check <code>status[v]</code></p></li><li><p>Actually printing the traversal path: DFS/BFS, then backtrack the <code>parent</code> array</p></li><li><p>Identifying/Counting/Labeling Connected Components (CCs) of undirected graphs: DFS/BFS, make use of the <code>status</code></p></li><li><p>Detecting if a graph is cyclic: modify DFS's <code>status</code> array to track:</p><ol type="1"><li><p><strong>unvisited</strong>: same as earlier, DFS has not reach vertex <strong>u</strong> before,</p></li><li><p><strong>explored</strong>: partially visited. DFS has visited vertex <strong>u</strong>, but at least one neighbor of vertex <strong>u</strong> has not been visited yet (DFS will go depth-first to that neighbor first),</p></li><li><p><strong>visited</strong>: now <strong>stronger</strong> definition: all neighbors of vertex <strong>u</strong> have also been visited and DFS is about to backtrack from vertex <strong>u</strong> to vertex <strong>p[u]</strong>.</p><p>Then, if encounter <strong>status[y] = explored</strong>, then it is a cycle.</p></li></ol></li><li><p>Topological Sort (only on DAGs),</p><ol type="1"><li><p>The DFS version requires just <strong>one additional line</strong> compared to the normal DFS and is basically the <strong>post-order</strong> traversal of the graph.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i</span>):</span></span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j, w <span class="keyword">in</span> al[i]:</span><br><span class="line">        <span class="keyword">if</span> visited[j]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        dfs(j)</span><br><span class="line">    topoOrder.append(i) <span class="comment"># add topoOrder</span></span><br><span class="line">    </span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">vertices = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">al = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    v1, v2, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    al[v2].append((v1, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># toposort</span></span><br><span class="line">topoOrder = []</span><br><span class="line">visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 0-based</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">        dfs(i)</span><br><span class="line"></span><br><span class="line">topoOrder.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> topoOrder:</span><br><span class="line">    <span class="keyword">for</span> j, w <span class="keyword">in</span> al[i]:</span><br><span class="line">        vertices[j] += vertices[i] * w</span><br><span class="line"><span class="built_in">print</span>(*vertices)</span><br></pre></td></tr></table></figure></li><li><p>The BFS version is based on the idea of vertices <strong>without incoming edge</strong> and is also called as Kahn's algorithm.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">in_degree = [<span class="number">0</span>] * V</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> al:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> al[i]:</span><br><span class="line">        in_degree[j] += i <span class="comment"># cal in degree</span></span><br><span class="line">        </span><br><span class="line">q = deque() <span class="comment"># a queue of vertices with indegree 0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">    <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>:</span><br><span class="line">        q.append(i) <span class="comment"># enqueue all v with indegree 0</span></span><br><span class="line">        </span><br><span class="line">cnt = <span class="number">0</span> <span class="comment"># cnt of visited vertices</span></span><br><span class="line">topoOrder = []</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    u = q.popleft()</span><br><span class="line">    topoOrder.append(u)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> al[u]:</span><br><span class="line">        in_degree[i] -= <span class="number">1</span> <span class="comment"># when reach, indegree - 1</span></span><br><span class="line">        <span class="keyword">if</span> in_degree[i] == <span class="number">0</span>: q.append(i) <span class="comment"># now can be put into topo</span></span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> cnt &lt; V: </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Cycle!&#x27;</span>) <span class="comment"># Why? Coz if cnt &lt; V, means some vertices still have indegree and thus not put into the queue. The remaining edges are the cycle.</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">  <span class="built_in">print</span>(*topoOrder)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="in-python">In Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for dfs, define a function dfs(), and remember to add the iteration limitation</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i</span>):</span></span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> al[i]:</span><br><span class="line">        <span class="keyword">if</span> visited[j]: <span class="keyword">continue</span></span><br><span class="line">        dfs(j)</span><br><span class="line">        </span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">al = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a, b = a-<span class="number">1</span>, b-<span class="number">1</span> <span class="comment"># convert to 0-based</span></span><br><span class="line">    al[a].append(b)</span><br><span class="line">    al[b].append(a)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">        <span class="built_in">print</span>(i + <span class="number">1</span>) <span class="comment"># 1-based</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag: <span class="built_in">print</span>(<span class="string">&#x27;Connected&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for bfs, remember to use deque and popleft()</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"></span><br><span class="line">INF = inf</span><br><span class="line">dist = [INF <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(V)]</span><br><span class="line">dist[s] = <span class="number">0</span></span><br><span class="line">q = deque()</span><br><span class="line">q.append(s)</span><br><span class="line">p = [-<span class="number">1</span> <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(V)]              <span class="comment"># parent</span></span><br><span class="line"></span><br><span class="line">layer = -<span class="number">1</span>                              <span class="comment"># for output printing</span></span><br><span class="line">isBipartite = <span class="literal">True</span>                      <span class="comment"># additional feature</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q):</span><br><span class="line">    u = q.popleft()</span><br><span class="line">    <span class="keyword">if</span> (dist[u] != layer):  <span class="comment"># new layer now</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nLayer &#123;&#125;: &quot;</span>.<span class="built_in">format</span>(dist[u]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    layer = dist[u]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;visit &#123;&#125;, &quot;</span>.<span class="built_in">format</span>(u), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> v, w <span class="keyword">in</span> AL[u]:                    <span class="comment"># w ignored</span></span><br><span class="line">        <span class="keyword">if</span> dist[v] == INF:</span><br><span class="line">            dist[v] = dist[u] + <span class="number">1</span>         <span class="comment"># dist[v] != INF now</span></span><br><span class="line">            p[v] = u                      <span class="comment"># parent of v is u</span></span><br><span class="line">            q.append(v)                   <span class="comment"># for next iteration</span></span><br><span class="line">        <span class="keyword">elif</span> dist[v] % <span class="number">2</span> == dist[u] % <span class="number">2</span>:  <span class="comment"># in the same set</span></span><br><span class="line">            isBipartite = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="sssp">SSSP</h2><ul><li>BFS for unweighted or constant weighted graph</li><li>Modified Dijkstra's Algorithm for weighted. (It is just the Uniform Cost Best Search). <strong>O((V+E) log V).</strong> It uses a Priority Queue via binary heap to maintain the search order. And this modified means a <strong>Lazy Update</strong> tech: leave the outdated ones in the PQ, and only check valid when meet them.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"></span><br><span class="line">INF = inf</span><br><span class="line"></span><br><span class="line">V, E, s = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>.split())</span><br><span class="line">AL = [[] <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(V)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">    u, v, w = <span class="built_in">map</span>(<span class="built_in">int</span>, f.readline().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    AL[u].append((v, w))                     <span class="comment"># directed graph</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (Modified) Dijkstra&#x27;s routine</span></span><br><span class="line">dist = [INF <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(V)]</span><br><span class="line">dist[s] = <span class="number">0</span></span><br><span class="line">pq = []</span><br><span class="line">heappush(pq, (<span class="number">0</span>, s))  <span class="comment"># 长这样：（vertex， dist）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sort the pairs by non-decreasing distance from s</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">len</span>(pq) &gt; <span class="number">0</span>):</span><br><span class="line">    d, u = heappop(pq)                  <span class="comment"># shortest unvisited u</span></span><br><span class="line">    <span class="keyword">if</span> (d &gt; dist[u]):</span><br><span class="line">        <span class="keyword">continue</span>                        <span class="comment"># *** a very important check. Lazy Update here</span></span><br><span class="line">    <span class="keyword">for</span> v, w <span class="keyword">in</span> AL[u]:                  <span class="comment"># all edges from u</span></span><br><span class="line">        <span class="keyword">if</span> (dist[u] + w &gt;= dist[v]):</span><br><span class="line">            <span class="keyword">continue</span>                    <span class="comment"># *** not improving, skip</span></span><br><span class="line">        dist[v] = dist[u] + w           <span class="comment"># relax operation</span></span><br><span class="line">        heappush(pq, (dist[v], v))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(V):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SSSP(&#123;&#125;, &#123;&#125;) = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(s, u, dist[u]))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;In IT5003, I am studying data structures and algorithms. The language we learn with is Python. So I take notes about what I learned, and how to use them in Python. I struct my notes based on data structures, and all the ADTs that are implemented by the data structures are discussed within. I focus on their usage, key design, and sometimes problems. In the future maybe I will append all the implementation codes.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;ADT: Abstract data type, from the point of view of a user, defined by its behavior.&lt;/li&gt;
&lt;li&gt;Data Structure: from the point of view of an implementer, concrete representations of data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;linear-data-structures&quot;&gt;Linear Data Structures&lt;/h1&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Notebook" scheme="https://jyzhu.top/tags/Notebook/"/>
    
    <category term="Data Structure" scheme="https://jyzhu.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Some notes on Searching and Sorting</title>
    <link href="https://jyzhu.top/Some-notes-on-Searching-and-Sorting/"/>
    <id>https://jyzhu.top/Some-notes-on-Searching-and-Sorting/</id>
    <published>2021-10-24T16:59:33.000Z</published>
    <updated>2021-11-03T11:10:05.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="searching-and-sorting">Searching and Sorting</h2><h3 id="searching-algorithms">Searching algorithms</h3><p>Search things in a list:</p><ul><li>if the list doesn't change frequently, better to sort first, then use binary-search everytime.</li></ul><h4 id="divide-and-conquer">Divide and conquer</h4><p>divide the problem into subproblems, solve them, merge them.</p><h3 id="sorting-algorithms">Sorting algorithms</h3><ul><li>in-place: Use a constant amount of memory. Everything can be in-place, except Mergesort.The in-place property is independent of loops/recursion stacks (in our class's definition)</li><li>stable: preserves the relative order of elements of the same value</li></ul><table><thead><tr class="header"><th>Sorting Algorithm</th><th>Average</th><th>Best</th><th>Worst</th><th>In-place</th><th>Stable</th></tr></thead><tbody><tr class="odd"><td>Bubblesort</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>Yes</td><td>Yes</td></tr><tr class="even"><td>Selection Sort</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>Yes</td><td><del>Yes</del> No</td></tr><tr class="odd"><td>Insertion Sort</td><td>O(n^2)</td><td>O(n) (nearly sorted)</td><td>O(n^2)</td><td></td><td></td></tr><tr class="even"><td>Mergesort</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>No</td><td>Yes</td></tr><tr class="odd"><td>Quicksort</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td><del>No</del> Yes</td><td>No</td></tr></tbody></table><table style="width:100%;"><colgroup><col style="width: 44%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 7%" /><col style="width: 16%" /><col style="width: 12%" /></colgroup><thead><tr class="header"><th>Algo/Input type</th><th>Random</th><th>Equal</th><th>Asending</th><th>Descending</th><th>Nearly Ascending</th><th>Nearly Descending</th></tr></thead><tbody><tr class="odd"><td>(Optimal) Bubble sort</td><td>O(N^2)</td><td>O(N)</td><td>O(N)</td><td>O(N^2)</td><td>O(kN) <em>but k not sig.</em></td><td>O(N^2)</td></tr><tr class="even"><td>(Min) Selection sort: <em>so poor, but you can find 3 smallest elems</em></td><td>O(N^2)</td><td>O(N^2)</td><td>O(N^2)</td><td>O(N^2)</td><td>O(N^2)</td><td>O(N^2)</td></tr><tr class="odd"><td>Insertion sort</td><td>O(N^2)</td><td>O(N)</td><td>O(N)</td><td>O(N^2)</td><td>O(N)</td><td>O(N^2)</td></tr><tr class="even"><td>Merge sort: <em>best!</em></td><td>O(N logN)</td><td>O(N logN)</td><td>O(N logN)</td><td>O(N logN)</td><td>O(N logN)</td><td>O(N logN)</td></tr></tbody></table><h6 id="mergesort">1. Mergesort</h6><ul><li><strong>about it's not in-place:</strong> it's not in-place, because need a new list when merging 2 lists.</li></ul><h6 id="quicksort">2. Quicksort</h6><ul><li><p><strong>about it's in-place</strong>: we do say quicksort is in-place, meaning it's space complexity is <span class="math inline">\(O(1)\)</span>, but we are talking about the space consumption in the <code>heap memory</code>. Considering extra memory consumption in the <code>stack memory</code>, we still need <span class="math inline">\(O(log n)\)</span> space, no matter for recursion one or iterative one.</p><blockquote><p>Yongqi's explanation:</p><p>Regarding the space complexity of quicksort, we said that it is in-place and therefore has O(1) space complexity. Strictly speaking, if we include the space required for stack frames for the recursive calls, we will need O(n) space in the worst case, and O(log n) space on the average case. However, because we have seen that in the worst case, we are basically doing bubble sort, then with some optimization we don't really need O(n) space, and the worst case space complexity would be O(log n). Furthermore, if we did quicksort iteratively, we would still need to maintain a stack data structure which would take up O(log n) space, and therefore it is correct to say that the space complexity of quicksort is O(log n). We said that it is O(1) space complexity, because we are pretending that stack frames take up 0 memory :P (or it is O(1) space complexity with respect to the heap memory).</p></blockquote></li><li><p>So I think it's ok to say it is 空间换时间</p></li></ul><h5 id="selection-sort">3. Selection sort</h5><ul><li><p><strong>about it's not stable:</strong> By definition, it will swap 2 elements, which causes unstable. However,</p><blockquote><p>Selection sort can be made Stable if instead of swapping, the minimum element is placed in its position without swapping i.e. by placing the number in its position by pushing every element one step forward. But we should also use linked list to implement the stable version, or the <code>insert</code> would be as slow as bubblesort</p></blockquote></li></ul><h5 id="bubble-sort">4. Bubble sort</h5><h4 id="not-comparing-sorting-algorithms">Not comparing Sorting Algorithms</h4><h5 id="counting-sort">1. counting sort</h5><p>适合：整数；很多的重复的同一种数，例如所有数都在0-100之间</p><p>缺点：额外空间</p><p>优点：O(n)</p><h5 id="heap-sort">5. Heap Sort</h5><p>Heapify: O(n)</p><p>top k elements: O(k logn) <em>(output sensitive)</em></p><ol type="1"><li>can stop at any time: extract the first k elements. When k &lt;&lt; n, this is very useful. O(n + k logn)</li><li>can be in-place: after extract the top element, put it at the last of the array.</li></ol><p>Heapsort is <strong>not cache friendly</strong>. Because the computer will predict that you'll read the array in sequence, so it will cache the following elems. Quicksort takes this advantage. Mergesort not.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;searching-and-sorting&quot;&gt;Searching and Sorting&lt;/h2&gt;
&lt;h3 id=&quot;searching-algorithms&quot;&gt;Searching algorithms&lt;/h3&gt;
&lt;p&gt;Search things in a list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if the list doesn&#39;t change frequently, better to sort first, then use binary-search everytime.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Python" scheme="https://jyzhu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Function Decorator, Map/Filter/Reduce in Python</title>
    <link href="https://jyzhu.top/Function-Decorator-Map-Filter-Reduce-in-Python/"/>
    <id>https://jyzhu.top/Function-Decorator-Map-Filter-Reduce-in-Python/</id>
    <published>2021-10-24T16:55:52.000Z</published>
    <updated>2021-10-24T16:56:29.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="function">Function</h2><h3 id="function-decorator">Function Decorator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">track</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the fn &#123;&#125; has x &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(fn, x))</span><br><span class="line">        <span class="keyword">return</span> fn(x)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="meta">@track</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>decorator equals to: <code>foo = track(foo)</code></p><h3 id="lambda">Lambda</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">lambda</span>            x            :          f(g(x))</span><br><span class="line"><span class="string">&quot;A function that    takes x    and returns     f(g(x))&quot;</span></span><br></pre></td></tr></table></figure><h3 id="map">Map</h3><p>Map will apply the function on elements in the iterables one by one, and return a map object (iterable).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(func, *iterables)</span><br></pre></td></tr></table></figure><ul><li>how many parameters the func require, how many iterables there are.</li><li>whenever one iterable reaches its end, the map will stop without an error.</li><li>map will return a map object. use <code>list()</code> to convert it to a list.</li></ul><h3 id="filter">Filter</h3><p>Filter passes each element in the iterable to the function, and if the function returns True, the element will be returned.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(func, iterable)</span><br></pre></td></tr></table></figure><ul><li>the func should require one parameter, and return boolean type.</li><li>unlike map, only one iterable is supported.</li><li>if the func doesn't return a boolean type, the filter simply returns the iterable itself.</li><li>also use <code>list()</code> to convert the filter object to a list.</li></ul><h3 id="reduce">Reduce</h3><p>Reduce takes the 1st and 2nd elements in the iterable, put them into the func, and take the return of the func and the 3rd element in the iterable, put them into the func again...</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">reduce(func, interable[, initial])</span><br></pre></td></tr></table></figure><ul><li>initial is literally an initial input into the func.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;function&quot;&gt;Function&lt;/h2&gt;
&lt;h3 id=&quot;function-decorator&quot;&gt;Function Decorator&lt;/h3&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;track&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;h&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;the fn &amp;#123;&amp;#125; has x &amp;#123;&amp;#125;&amp;#x27;&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;format&lt;/span&gt;(fn, x))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fn(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@track&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x ** x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(foo(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;decorator equals to: &lt;code&gt;foo = track(foo)&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Python" scheme="https://jyzhu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Iterable/Sequences in Python</title>
    <link href="https://jyzhu.top/Iterable-Sequences-in-Python/"/>
    <id>https://jyzhu.top/Iterable-Sequences-in-Python/</id>
    <published>2021-10-24T16:48:30.000Z</published>
    <updated>2021-10-24T17:06:33.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iterablesequences">Iterable/Sequences</h1><p>Strings, ranges, lists and tuples.</p><blockquote><p>“An iterable which supports efficient element access using integer indices via the <code>__getitem__</code> special method and defines a <code>__len__</code> method that returns the length of the sequence.”</p></blockquote><ul><li><p>use one index to fetch item in a <strong>list</strong>, the index can't out of the range; but if use <strong>slice</strong> method, then you <strong>can do it out of the range</strong>, because the slice will autolly find the greediest indexs.</p></li><li><p>assigning a list to another list, like <code>a = b</code>, makes a and b refers to the same list. And a list is mutable. So if we change a, then b will also be affected. It's called <strong>alias</strong>. Do avoid this.</p></li><li><p><strong>Tuple</strong> also has order. Just it's immutable.</p></li><li><p>Fxxxk, Tuple and <strong>Set</strong> are different things! A set is like <code>&#123;1, 2, 3&#125;</code>, that is what I thought as not ordered and not duplicated. And a set has <code>intersection()</code> <code>union()</code> <code>difference()</code> <code>symmetric_difference()</code>.</p><p>To delete items in a set:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1.discard(<span class="number">6</span>) <span class="comment"># If the item doesn&#x27;t exist, no exception</span></span><br><span class="line">set1.remove(<span class="number">6</span>) <span class="comment"># Raise an exception if doesn&#x27;t exist</span></span><br><span class="line">set1.pop() <span class="comment"># randomly delete one item.</span></span><br></pre></td></tr></table></figure></li><li><p>you can insert an interable in a list's slice, though they have different length!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>:<span class="number">3</span>] = [<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>list()</code> takes an iterable, and makes it a list;</p><p><code>str()</code> shows you the whole object's look.</p></li><li><p><code>range()</code> is also an iterable. It can be slicing, and len()</p></li><li><p><code>a, b = b, a</code>: the <code>b, a</code> on the right firstly is packed into tuple: <code>(b, a)</code>, then it is unpacked and individually assigned to each var on the left</p></li></ul><h2 id="sequence-operations">Sequence operations</h2><p>All: (list tuple str range)</p><figure><img src="https://i.loli.net/2021/10/25/m48Tpaile1CRPGO.png" alt="image-20210825165741137" /><figcaption>image-20210825165741137</figcaption></figure><figure><img src="https://i.loli.net/2021/10/25/QsPcdxuvBjZGDKF.png" alt="image-20210825165757277" /><figcaption>image-20210825165757277</figcaption></figure><p>Except range:</p><figure><img src="https://i.loli.net/2021/10/25/XqwiCoefWLb2Fjz.png" alt="image-20210825165814598" /><figcaption>image-20210825165814598</figcaption></figure><p>List:</p><figure><img src="https://i.loli.net/2021/10/25/fEFmnzPMvltLKwQ.png" alt="image-20210825165842016" /><figcaption>image-20210825165842016</figcaption></figure><h2 id="list">List</h2><p><code>l.extend()</code> treats the input as an iterable, and take each element of the iterable as a new element;</p><p><code>l.append()</code> treats the input as a new element.</p><p><code>l.pop()</code> Pop and return element of some index (if omitted, pop last element)</p><p><code>l.remove()</code> Remove first occurrence of element</p><p><strong>be careful which methods can cause runtime error</strong></p><p><strong>for-comprehension</strong>: <code>elem for var in interable if cond</code></p><p><code>all(&lt;iterable&gt;)</code>: whether all are true</p><p><code>any(&lt;interable&gt;)</code>: any true</p><h2 id="generator-expressions">Generator expressions</h2><blockquote><p>only retrieve elements when need</p></blockquote><h3 id="yield-expression">Yield expression</h3><p>Generator functions are written using the function* syntax. When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line"><span class="meta">... </span>   cur = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> cur</span><br><span class="line"><span class="meta">... </span>       cur += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">generator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> f():</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>###迭代器和生成器</p><ul><li>迭代器 an iterable，跟sequence不同的是它不能slicing，也不一定有len()，因为是可以无穷的。其定义就是一个实现了<code>__iter()__</code>和<code>__next()__</code>方法的对象。从道理上来讲是一个可以遍历sequence，并且记住遍历位置的对象。直到访问完所有元素，抛出一个<code>StopIteration</code>异常。</li><li>生成器 a generator：使用了<code>yield</code>的函数，必然返回一个迭代器。用起来和迭代器是一样的。<ul><li>至于<code>yield</code>的用法，在运行生成器的时候，其实也就是<code>next(&lt;generator&gt;)</code>的时候，函数会运行，直到遇到yield，就暂停并保存当前运行信息，返回yield的值；下一次运行时从当前位置继续</li></ul></li></ul><h2 id="dict-and-set">Dict and Set</h2><ul><li><p>Use short-circuit evaluation to fetch a key in a Dict, but if it doesn't exist, it will return a False, instead of raising an error:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Toronto&#x27;</span> <span class="keyword">in</span> MLB_team <span class="keyword">and</span> MLB_team[<span class="string">&#x27;Toronto&#x27;</span>]</span><br><span class="line"><span class="comment"># if &#x27;Toronto&#x27; is in the list, =&gt; True and xxx, it will return the xxx;</span></span><br><span class="line"><span class="comment"># if it&#x27;s not in the list, =&gt; False and xxx, it will return False and skip running the xxx.</span></span><br></pre></td></tr></table></figure><p>But <code>d.get()</code> method is similar. It will give a <code>None</code> if the key doesn't exist.</p></li><li><p>set can only contains hashable items. <code>set</code> is unhashable. So a set can't be put into a set.</p></li><li><p>All mutable types are unhashable</p></li><li><p><code>set()</code> function picking up an iterable and use it one by one to create a set. so <code>set(&#123;1,2,3&#125;)</code> is ok.</p></li><li><p><code>frozenset</code> is immutable, so also hashable. so can be put into a set.</p></li></ul><h2 id="hash">hash</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1.0</span>])</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n1 = <span class="number">1234e23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n2 = <span class="number">1234e23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2)</span><br><span class="line">(<span class="number">4318748880</span>, <span class="number">4318749104</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(n1), <span class="built_in">hash</span>(n2)</span><br><span class="line">(<span class="number">539300935830116283</span>, <span class="number">539300935830116283</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>Strange</strong>: Python's behavior is different in shell/script/ways:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n1, n2 = <span class="number">1234e23</span>, <span class="number">1234e23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2)</span><br><span class="line">(<span class="number">4317529008</span>, <span class="number">4317529008</span>)</span><br></pre></td></tr></table></figure><h3 id="hash-for-built-in-data-types">1. hash for built-in data types</h3><ul><li><p>For built-in immutable data types (i.e. <strong>float, str, int</strong>), <code>hash</code> uses their <strong>value</strong>, so, <code>x == y</code> =&gt; <code>hash(x) == hash(y)</code></p></li><li><p>For <strong>tuple</strong>, hash depends on its elements. So, some tuple are hashable, some are not. depends on whether members are all hashable:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1, t2 = (<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t1)</span><br><span class="line"><span class="number">7760687994730794974</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>hash is <code>None</code> for built-in mutable types (i.e. <strong>list, set, dict</strong>)</p></li></ul><h5 id="hash-for-user-defined-classes">2. hash for user defined classes</h5><ul><li>For user defined classes, by default：<ul><li><code>__hash__</code> and <code>__eq__</code> are based on <strong>id</strong> by default (but they can be overriden) (so, by default, <code>hash</code>, <code>==</code>(equal) and <code>is</code> are the same)</li><li>duplicate is defined as: <code>x == y</code> &lt;=&gt; <code>x is y and hash(x) == hash(y)</code></li><li>如果你改了<code>equal</code>的逻辑，那么就要把<code>hash</code>的逻辑也改了，否则就会变成<code>None</code></li></ul></li><li>说人话：<ul><li>默认来说，全都看id</li><li>如果光改了eq，那hash就成none了。想保留hash的话，要满足这个条件：只要ab全等，必须ab哈希值一样（不然你是魔鬼）</li></ul></li><li>哈希冲突 (collision): 不同的元素（<code>a == b： False</code>）经过哈希函数后发现哈希值一样（<code>hash(a) == hash(b)</code>）。是需要一些策略来进行处理，以确保把这些元素都储存下来的</li><li>重复（duplicate）：两个元素<strong>全等</strong>（而不是id一样！！！），hash得到的值又一样（<code>a == b and hash(a) == hash(b)</code>），自然认为是同一个元素，直接覆盖了</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;iterablesequences&quot;&gt;Iterable/Sequences&lt;/h1&gt;
&lt;p&gt;Strings, ranges, lists and tuples.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“An iterable which supports efficient element access using integer indices via the &lt;code&gt;__getitem__&lt;/code&gt; special method and defines a &lt;code&gt;__len__&lt;/code&gt; method that returns the length of the sequence.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;use one index to fetch item in a &lt;strong&gt;list&lt;/strong&gt;, the index can&#39;t out of the range; but if use &lt;strong&gt;slice&lt;/strong&gt; method, then you &lt;strong&gt;can do it out of the range&lt;/strong&gt;, because the slice will autolly find the greediest indexs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;assigning a list to another list, like &lt;code&gt;a = b&lt;/code&gt;, makes a and b refers to the same list. And a list is mutable. So if we change a, then b will also be affected. It&#39;s called &lt;strong&gt;alias&lt;/strong&gt;. Do avoid this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tuple&lt;/strong&gt; also has order. Just it&#39;s immutable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fxxxk, Tuple and &lt;strong&gt;Set&lt;/strong&gt; are different things! A set is like &lt;code&gt;&amp;#123;1, 2, 3&amp;#125;&lt;/code&gt;, that is what I thought as not ordered and not duplicated. And a set has &lt;code&gt;intersection()&lt;/code&gt; &lt;code&gt;union()&lt;/code&gt; &lt;code&gt;difference()&lt;/code&gt; &lt;code&gt;symmetric_difference()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To delete items in a set:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set1.discard(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# If the item doesn&amp;#x27;t exist, no exception&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set1.remove(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# Raise an exception if doesn&amp;#x27;t exist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set1.pop() &lt;span class=&quot;comment&quot;&gt;# randomly delete one item.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;you can insert an interable in a list&#39;s slice, though they have different length!&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;list()&lt;/code&gt; takes an iterable, and makes it a list;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str()&lt;/code&gt; shows you the whole object&#39;s look.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;range()&lt;/code&gt; is also an iterable. It can be slicing, and len()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;a, b = b, a&lt;/code&gt;: the &lt;code&gt;b, a&lt;/code&gt; on the right firstly is packed into tuple: &lt;code&gt;(b, a)&lt;/code&gt;, then it is unpacked and individually assigned to each var on the left&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Computer Notes" scheme="https://jyzhu.top/categories/Computer-Notes/"/>
    
    
    <category term="Python" scheme="https://jyzhu.top/tags/Python/"/>
    
  </entry>
  
</feed>
